%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%      This file is part of the 'openLilyLib' library.                    %
%                                ===========                              %
%                                                                         %
%              https://github.com/lilyglyphs/openLilyLib                  %
%                                                                         %
%  Copyright 2012-13 by Urs Liska, lilyglyphs@ursliska.de                 %
%                                                                         %
%  'openLilyLib' is free software: you can redistribute it and/or modify  %
%  it under the terms of the GNU General Public License as published by   %
%  the Free Software Foundation, either version 3 of the License, or      %
%  (at your option) any later version.                                    %
%                                                                         %
%  This program is distributed in the hope that it will be useful,        %
%  but WITHOUT ANY WARRANTY; without even the implied warranty of         %
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           %
%  GNU General Public License for more details.                           %
%                                                                         %
%  You should have received a copy of the GNU General Public License      %
%  along with this program.  If not, see <http://www.gnu.org/licenses/>.  %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../../LilyPond-Tutorials]{subfiles}

\begin{document}
\parttitle[Urs Liska]{Writing (About) Music with Tools Based on Plain Text}
\begin{authorAbstract}{Urs Liska}
Abstract
\end{authorAbstract}

\chapter{Introduction}


\section*{\textsc{wysiwyg} and Plain Text}

But there is also a completely different approach, which is based on plain text file formats.
The fundamental difference here is that such programs draw a clearer line between the definition of file content (in so-called source files) and the graphical output.
They focus less on intuitive editing of the result but rather on allowing a clean and unambiguous (semantic) description of the content, while leaving the graphical rendering of the results more to the software.

Today there are some intersections between the two concepts because \textsc{wysiwyg} programs may store their documents in some sort of text file formats, but traditionally these programs have binary file formats that usually are more memory efficient but can only be understood by the programs themselves.
And typical text based programs may have other programs, so called “front-ends” that try to mimick a graphical user interface as best as they can.

Before discussing now how this affects the user interface or user interaction in several programs I'd like to think a little bit about the implications that the storage in plain text files has in general:

\paragraph{In-place comments}
Practically all plain text formats allow to enter comments inside the source file.
This allows to unintrusively but permanently mark something in the file
without any impact on the visual appearance of the result.

\paragraph{Ready for “diffs”}
Maybe the most important aspect of plain text files is that they are being \emph{diffable}.
This means they are accessible to programs (so-called \emph{diff-viewers}) that perform line-by-line comparisons of different versions of a file.
This makes them ready for \emph{version control} and also for other techniques well-known in software development.
The major impact of this concept is on the way one can collaborate on projects.

\bigskip

On the following pages I will present four programs/systems that can be taken as good examples, and that especially can act as a very good toolchain for  documents with and about music:

\paragraph{Markdown} -- a simple markup language offering formatted display of plain text files.

\paragraph{\LaTeX} --
the professional typesetting system for (text) documents.

\paragraph{LilyPond} --
a powerful music notation software.

\paragraph{Git} --
the Distributed Version Control System that keeps it all together.


\chapter{Markdown and an Introduction to Versioning}
As a gentle introduction into the topic of this paper I'll start with a short description of \emph{Markdown}, a simplistic markup language (word-play intended by the authors of Markdown).
Markup languages%
\footnote{\url{http://en.wikipedia.org/wiki/Markup_language}}
are used to annotate text documents with additional information about their structure, semantics or intended appearance.
They usually use additional \emph{tags} that are syntactically separated from the content and that contain the markup information.
The most widely-known markup languages are probably \textsc{html} or \textsc{xml}.
Consider the following minimal \textsc{html} document which could be a simple page of a website:

\begin{lstlisting}[language=HTML]
<html>
  <head>
    <title>Interesting Topic</title>
  </head>
  <body>
    <p>
      This is a paragraph with a <strong>highlighted</strong> word.
    </p>
  </body>
</html>
\end{lstlisting}

You can see a few things with this small document:
\begin{itemize*}
    \item It is plain text.
    \item You (a human) can read this text and understand its meaning, although it isn't too expressive.
    \item The content text is surrounded by tags that describe the type of content they surround (e.\,g. a title or a paragraph).
    \item These tags are \emph{semantic} markup because they describe the \emph{type} of content and not its \emph{appearance}.
    the \texttt{<strong></strong>} pair of tags doesn't define how this will look like in a web browser (although it is common that the browser will display this as bold text).
\end{itemize*}

Maybe you have noticed that the markup tags are using up the better part of the document while the content is rather short.
Of course this ratio depends heavily on the character of the actual document, but it is a general tendency -- that gets even stronger with the \textsc{xml} markup language which goes into much more detail with its markup.
It is a problem with this approach that the markup tends to disturb the perception of the content.

Markdown intends to improve that situation by providing a similar annotation of source files without the overhead of the additional markup tags.
According to its authors%
\footnote{\url{http://daringfireball.net/projects/markdown/}}
“Markdown allows you to write using an easy-to-read, easy-to-write plain text format”.
It is a plain text formatting syntax with the goal of allowing to write documents that visually represent their structure without additional markup.
They can then be converted to other -- styled -- formats.
Take the following hypothetical CHANGES.txt file for a computer program:
\begin{lstlisting}[frame=single]
My first program

Program maintained by John Doe (john.doe@myfirstprogram.org)

Changelog

2013-03-16: Add reference material
2013-03-15: Fix annoying bug: Program now opens files

v.0.5.2
- Add 'Save' menu item
- Add splash screen

v.0.5.0
...
\end{lstlisting}

With Markdown you would write the same as (for example):
\begin{lstlisting}[frame=single]
# My first program

Program maintained by [John Doe](john.doe@myfirstprogram.org)

---

## Changelog

### Current Nightly Build
**2013-03-16:** Add reference material  
**2013-03-15:** Fix annoying bug: Program now opens files

### v.0.5.2
- Add 'Save' menu item
- Add splash screen

### v.0.5.0
...
\end{lstlisting}

\noindent which a Markdown-aware editor would for example display formatted as

\todo{Screenshot}

The formatting elements used in the source file are designed in a way to visually indicate the structure of the content, e.\.g the different levels of headings, horizontal rules, list items or hyperlinks.
Of course there are many more syntactical elements, and this is only a very superficial example.
This technique is also used quite often in web forms (e.\,g. in forums), where you can enter Markdown formatted text that is then rendered as formatted \textsc{html}.

Some editors can export Markdown formatted text to a variety of other formats such as \textsc{html}, word processor formats or to a \textsc{pdf} document.
Beyond that the \emph{pandoc} tool%
\footnote{\url{http://johnmacfarlane.net/pandoc/}}
offers a great variety of document formats it can convert to and from.
So Markdown is a very handy tool for writing notes and short sketches.
It is quite resource efficient and uses way less overhead than using full-fledged word processors for such small tasks.

\todo{Editors for different OSs}

\todo{Make all this \emph{slightly} more explicit.}

\section{Introduction to Source Code Versioning}
\label{sec:intro-versioning}

After this gentle introduction to the basics of the “source code” concept%
\footnote{\todo{Better expression}}
I will try to give you a similarly gentle first impression of the nature of \emph{Source Code Version Control}.
It really is only an impression and not an introduction, as I won't tell you how to actually \emph{do} anything.
I'll only describe the underlying concepts and name a few keywords associated with them.

As a first approximation you may understand version control as a huge and infinitely flexible undo/redo implementation.
Versioning stores the complete history of your document or project and lets you investigate \emph{any} state it has been in over time.
Furthermore it lets you roll back (or reapply) \emph{any} change you have applied at any time, not necessarily in (reverse) chronological order.

Suppose two weeks ago you reworked a chapter of your book and now you realize that this reworking was based on false assumptions -- you need to remove these changes and try to get the chapter into the state it had been before.
With a traditional toolchain you would be lucky to have a version of that state at hand, either as a backup file or printed on paper.
With the backup file you may roll back your work to that state -- but of course you lose all work done afterwards.
Or you could put the (digital or printed) backup and the current version side by side and manually emend the changes you applied.
Both solutions are cumbersome, error prone, and they rely on the -- random -- existence of a backup of exactly the desired state.

With a document under version control you may identify the exact changeset that you want to undo and just revert these changes -- and leave everything done before or after the way it is.
You think that's cool? I can tell you it \emph{is}!
I dare say this insight changed my life as a document author when I started to realize the potential of it about half a year ago.
And this is just the surface -- we'll deal with other, maybe even more important aspects of versioning in the last chapter of this paper.

\medskip
Now let's have a look how this is achieved.
The tool of choice for version control today is \emph{Git}%
\footnote{\url{http://git-scm.com/}},
a \emph{Distributed Version Control System}.
If you never used such tools but may have heard of programs like \emph{CVS} or \emph{Subversion} don't bother with them and go for Git.
(If you already use one of them it may be a different story, but I can't advise you then -- although I have the impression that people moving to Git from other versioning systems usually seem to be extremely happy about it.)
I won't go into detail here because the difference between centralized and distributed version control doesn't affect the basic concepts of versioning, but we'll talk about that later.

The first step is to initialize a directory on your disk as a \emph{Git repository}.
This repository consists of the \emph{working tree} -- which corresponds to the directory structure your files are in -- and the core repository (a hidden directory) containing all the history of your project.
Each time you have finished a distinct set of changes (e.\,g. sketched a chapter, cleaned up formattings, done proof-reading or whatever seems appropriate) you tell Git about them by \emph{committing the changes}.
Git now compares the contents of the directory \emph{line by line} (one says it makes a \emph{diff}) and stores the changes in this commit.
The list of previous commits forms the history of your project, and as you can supply a short header and a longer description for each commit you will be able to easily identify any specific changeset later.

To make this clearer we'll look at a concrete example.
Say you update the previous CHANGES document and now it looks as following:
\begin{lstlisting}[frame=single]
# Hello World - my first program

Program maintained by [John Doe](john.doe@myfirstprogram.org)

---

## Changelog

### Current Nightly Build
**2013-04-01:** Change program title  
**2013-03-16:** Add reference material  
**2013-03-15:** Fix annoying bug: Program now opens files

### v.0.5.2
- Add 'Save' menu item
- Add splash screen

### v.0.5.0
\end{lstlisting}

If you commit this change to Git it will recognize and store that you modified the first line and added another line in the “Current Nightly Build” section.
The comparison result will look similar to the following (slightly simplified) record:

\begin{lstlisting}[language=diff, frame=single]
- # My first program
+ # Hello World - my first program

  Program maintained by [John Doe](john.doe@myfirstprogram.org)

...

  ## Changelog

  ### Current Nightly Build
+ **2013-04-01:** Change program title  
  **2013-03-16:** Add reference material  
  **2013-03-15:** Fix annoying bug: Program now opens files
\end{lstlisting}

The diff only prints two excerpts of the document, and it precedes some lines with a plus and others with a minus sign.
“Minus” lines have been removed from the later version of the file, while “plus” lines point to added lines.
In the first two lines you see the visualization of a modified line: the original line is marked as removed while the new version of the line is marked as added.
The changed lines are surrounded by a few of the unchanged ones to give you the necessary context to understand where in the file we are.
This may not seem necessary in this example, but you'll appreciate it when the diff shows you exactly the seven changed lines in a file with more than 2.000 lines.

It should be mentioned that this example uses only one modified file, while in real work you will equally have commits that contain modifications in multiple files that form a coherent set of changes.

This little example shows quite strikingly why versioning only works well with plain text files.
In our commit Git knows exactly which changes we have applied to the file and only stores these changes.
If we would deal with a binary (e.\,g. an image) file  Git couldn't compare the versions line by line, which has two consequences:
Git does only know \emph{that} the file has been changed but doesn't have any idea \emph{how}, and it is forced to store a complete version of the file for each commit, which can sum up quite fast if we are talking about large media files.
Therefore one usually excludes binary files from being tracked through Git.
We will talk about the implications of this issue in the last chapter.

\medskip
There are two more things you should have heard of in this early stage: \emph{history} and \emph{checking out}.
As mentioned a Git repository manages the whole history of a project.
Printing such a history may look similar to this excerpt:

\begin{lstlisting}[frame=single]
364e9df3 Change program title
8b881b89 Add reference material
785969e1 Document fix for #14
8df62c9b Fix #14: Program now opens files
e14820c9 Add 'Save' menu button
d9df8b43 Add splash screen
70ec5fca Finish first working version
\end{lstlisting}

This is a list of seven commits (order in reversed chronology).
Each commit has a unique ID and a commit message header which you can use to identify a specific changeset you are interested in.
Now you can \emph{checkout} any commit you like.
Git will then set your working tree to the state it has been at that commit.
This means it will change modified files or will even delete files that have been added after that commit.
As mentioned earlier your repository has two parts, the working tree and the (hidden) bare repository.
While the hidden repository contains the complete history (i.\,e. every state of every file) the working tree is comparably volatile and will be changed often by Git.
Without providing concrete examples it is good to know that this way you can inspect -- and modify -- any previous state of your project.
And it is even better to know that you can checkout the latest commit again which will bring back all your files in their latest state.
It is actually very hard to irreversably destroy data once it has been committed to Git!

\chapter{\LaTeX}
\emph{Markdown} documents did serve us well getting a first impression of plain text documents and versioning.
But it may be worth to note that they are not the typical representative of source code files.
Usually when saying “source code” we are talking about a plain text \emph{input file} that is \emph{compiled} to an \emph{output file}.
The most common cases for this are source files in a programming language that are compiled to an executable computer program.
But there are also other approaches where \emph{source} or \emph{input} documents are compiled to a presentation format.
And this is what we are going to discuss in the following chapters.

While Markdown documents are good for notepad-like sketches, there is one fully-featured system for professionally typesetting text documents of any size: \LaTeX.
Historically the original motivation was to be able to typeset mathematical formulas as part of text documents, but there also has always been the strong commitment to professional typography.
\LaTeX{} strives to allow document authors to benefit from the craftsmanship of traditional typesetters, which typically isn't accessible from word processors (or from document authors, to be honest).
One specific target is the typesetting of books, i.\,e. really long documents of several hundred pages, a task word processors generally have severe problems with.

\subsection*{\todo{Architecture}}

\begin{itemize}
\item Core, “distribution", packages
\end{itemize}

\subsection*{Editing Environment}
A concept that may be completely new to you (although I mentioned it in the introduction) is the independence of the \LaTeX{} distribution to the \textit{source editor} as well as of the editor to the visible document.
As you'll probably have understood by now \LaTeX{} compiles source files into an output format, usually \textsc{pdf}.
And as these source files are plain text files you may edit them with any text editor you prefer.
The question of the editor may seem surprising for the average Windows or Mac user, as most of them rarely use them (Notepad on Win, TextEdit on Mac).
But when it comes to editing “source code” this question becomes much more interesting.

We have seen \textit{Markdown} so far which tries to achieve as much as possible without additional markup, and we have seen a small \textsc{html} example which does have quite extensive markup.
\LaTeX{} of course is yet another \textit{markup language} introducing additional text elements in the document that describe it semantically.
The key to effectively working with plain text source files is \textit{syntax highlighting}.
This basically means that the editor knows about the language syntax of the document it is working on and displays the source in a formatted way that makes it vastly easier to read.
There are numerous editors that support syntax highlighting, basically this works by color-coding elements and using a monospaced font.
You'll see comparison screenshots soon, when we have covered the basics of \LaTeX's syntax.

But while many editors support syntax highlighting for a great number of languages there are programs explicitely intended for working with specific languages (like \LaTeX{} for example).
These assist you to differing extent in developing documents.
Without such programs the basic workflow in working with a system like \LaTeX{} (or any compiled language) would be to 1) edit the document and save it to disk, 2) run \LaTeX{} (possibly from the command line) to compile the document, and 3) open the resulting \textsc{pdf} in a document viewer.
Dedicated editors offer more than syntax highlighting and integrate the whole development process in one program, offering tools to insert commands, provide a document outline, error parsing, preview etc.
Depending on the level of assistance one may also call these programs \textit{Integrated Development Environment}, or short “\textsc{ide}”.

\todo{Name editors for all major OSs}

\subsection*{Basic syntax of \LaTeX{} documents}
Now let's have a first look at a minimal \LaTeX{} document:
\begin{lstlisting}[%
    frame=single,
    language={[LaTeX]TeX}]
\documentclass{article}

\begin{document}
\section{This is a section}
    This is the content
\end{document}
\end{lstlisting}

If you save this file and run \LaTeX{} on it you will get a nearly empty pdf document with only the sentence “This is the content” at the top of the page.
This document already exposes three major concepts of \LaTeX{} documents: the \textit{document class, commands/macros} and \textit{environments}.
You can \textit{very roughly} compare them to document templates, character and paragraph styles in word processor or layout programs, but they are more versatile and powerful.

The \textit{document class} is the base on which every \LaTeX{} document is built.
Like a document template it can contain style sheets and layout elements, and it determines the overall layout, but it can also define a plethora of functionality enhancements.
\todo{Think about at least a few examples.}
The most common document classes are \textit{article, report, book} but there is a huge number of available document classes for nearly any conceivable purpose.
If none of them does fit your needs you can still create your own class, as a kind of “house template” or for any specific document.

The \textit{command} (or \textit{macro}) is \textit{expanded} to its definition, and it may use arguments for that.
In our example it is \cmd{section} that takes one argument: the text to be used for the section heading.
This is formatted (according to the definition in the document class) as a paragraph, but additionally \LaTeX{} takes care of adding an entry in the table of contents.
There are commands without arguments that just \textit{do} something, like e.\,g. \cmd{bigskip} which inserts vertical distance between two paragraphs, or commands with one argument that are exactly used like character styles in word processors.
For example there is the command \cmd{emph\{\}}, which \emph{emphasizes} the text inside the curly braces (its \emph{argument}), usually by printing it in italics (but if it occurs in an already italic context, it does the opposite).

You see that these examples of built-in commands are \emph{semantic} markup commands that describe the type of the content, not its visual appearance.
This concept is of course very similar to the policy of only using style sheets instead of direct formatting in word processor documents.
Apart from using built-in commands you can define your own commands describing the content types of your documents.
These may be simple things like \cmd{composer}, e.\,g. highlighting composer names with green small caps, but you can (with a little experience) also create quite sophisticated commands.
For example I use a custom command \cmd{revisionEntry} for a critical report that takes four arguments: a measure number, the reference point within the measure, the affected voice/part, and the actual description.
The first three arguments are enclosed by separator characters, the last one gets a different font.
If one of the first argument (e.\,g. the reference point) is empty the separator character will be suppressed.

\todo{add example/screenshot}

As you saw commands often act as character styles but can also go way beyond that, the same is true for \emph{environments}.
Environments enclose some content that can span multiple paragraphs.
The \env{document} environment we saw in the example is a special case: Just like the document class it is a mandatory part of \emph{any} \LaTeX{} document and encloses the whole visible part of the document (just like the \verb+<body></body>+ tags of a \textsc{html} document%
\footnote{While we're at it: the lines between \cmd{documentclass} and \cmd{begin\{document\}} are the \emph{preamble} that corresponds to the \texttt{<head></head>} part of a \textsc{html} document.
It is here where you can put any configuration or extensions to your document.}).
As with the commands there is also a great number of built-in and predefined environments available, and you can define your own.
An environment is for example the solution when you want to typeset a quotation with additional indent (the \env{quotation} environment), and they are also used for things like tables, figures, multi-column sections etc.
Enviroments can also be used to print arbitrary items before and after the content, and they can process arguments, so you can create very sophisticated settings with them too.

One important aspect to environments is that they can be \emph{floating}.
This means that they aren't necessarily printed immediately, but \LaTeX{} may decide (based upon well-tested typographical rules) where to actually place them.
It may make people feel uneasy to (seemingly) give away some amount of control, and I wouldn't use that when designing a small brochure.
But in the context of creating books or other long text documents this is actually a huge advantage, as you usually don't have to worry at all about page breaking, even when you insert of remove text afterwards or decide to change the page layout.

\medskip
Having all this in a plain text file does actually require some time getting used to.
I'm still not completely convinced by the claim that this approach helps you reduce the distraction from authoring your \emph{content} that you'd have by caring about the \emph{appearance} too early.
It actually \emph{is} distracting if you have to lookup commands in manuals (instead of skimming menus), and I am still somewhat distracted by the markup strings in the document.
But this is clearly outweighed by having all information explicitely written in the document.

Take the following example excerpt:

\begin{lstlisting}[language={[LaTeX]TeX}]
This is some \textbf{bold} text.
Followed by a \composer{composer name}
and a \composition{composition title}.
\end{lstlisting}

When you are looking at the plain text file you don't know how this will appear in the final output, and you may have to use some extra energy to mentally “skip” the markup -- but you clearly see the semantic attribution.
In the final printout you may decide to print all three styles as bold.
But even if you do so you still have the non-ambiguous markup in the source file.
Compare this to the screenshot of the same passage in a word processor file.
You couldn't tell there that three different style sheets have been used, moreover you can't safely assume that you actually \emph{did} use the correct styles without selecting them one after another.

\todo{add LibreOffice screenshot}

Similarly you can enter constructs like \verb+\,+ (for a typographical small space), or \verb+\\+ (for a line break), which may indeed somewhat clutter your source file in situations where it is used heavily.
But as in the previous example you have the contents explicitely and non-ambiguously written into the source file.
The same is true for comments that can be written into the documents in a completely transparent manner.
This can be used for TODO-like comments or as real annotations that shouldn't be printed.

\todo{Example}

Another aspect to this topic is that markup in plain text file is directly accessible to search\,\&\,replace operations, making it quite easy to keep the document in a consistent state if you had to change something.


\subsection*{Extending capabilites with packages and classes}
As explained earlier a \LaTeX{} distribution has an inner (\TeX) and outer {\LaTeX} core and a huge number of \emph{extension packages} that are installed but not used by default.
Loading packages takes some time, therefore it seems a good compromise to only load fundamental packages by default and load the more advanced (or at least less common) packages only on explicit request.
The available packages are practically endless, and I can only (randomly) name a few of those that I regularely use:
\begin{itemize*}

\item[\textbf{booktabs}] Professionally formatted tables
\item[\textbf{cleveref}] Smart cross-referencing with features like automatic setting of texts like “on the next page”, “on page X” or no reference text at all.
\item[\textbf{graphicx}] Include images
\item[\textbf{afterpage}] Do something at the beginning of the next page (while continuing the text on the current page)
\item[\textbf{pdfpages}] Include pdf documents inside the document.
\end{itemize*}
 
There are packages for editing page layout, creating vector graphics, typesetting formulas, creating screen presentations etc.
As \LaTeX's focus is on creating books it is a matter of course that there is also strong and robust support for creating bibliographies, indices, working with smaller subfiles etc.

As with commands and environments you can (and will) define your own document classes and packages, which can be mainly used to hide away complexity and make your main document more readable.
In addition you can make use of them in order to reuse your configuration material.
For example you could have a custom package \env{musicstyles} which contains “character styles” for musical elements like composer, work, opus, Riemann function, etc. and use this for any document about music.
Or you could have (like me) a package with some basic configuration and style sheets that you will use in practically any document you'd write at all -- so you don't have to bother about that anymore.

You will also want to write document classes for certain types of documents you need regularely.
The document class will include necessary (available and custom) packages and create new specific commands and environments.
If done efficiently this can enable you to create even complex documents from very minimal input documents.
The following document for example

\begin{lstlisting}[language={[LaTeX]TeX}]
\documentclass{concertProgramme}

\begin{document}

\programmeTitle{\dots{} Without Words}
\interpreter{NN} Piano

\godowksySchubertSongs

\giesekingStraussSongs

\intermission

\begin{programmeItem}
    \composer{Robert Schumann}
    \compositionTitle{Carnaval} op.\,9\\
    \life{1810\bis 56}
    \subtitle{\textit{Scènes mignonnes sur quatre notes}}
\end{programmeItem}
\end{lstlisting}

\noindent will be processed into a fancy concert programme with graphical layout elements -- given that the programme items have been pre-defined in a “repertoire” package!

\subsection*{Specifically musical issues}

Now we're finally approaching the topics we were after right from the beginning: writing about music.
But I first have to tell you that I won't got into much detail yet.
It is better to delay this until we also have an impression about LilyPond, the musical engraving program.
For now you can take note of the presence of a few tools that can aid you greatly in authoring musical text documents.

\paragraph{musicexamples} is a package that is part of the same \openlilylib{} family of resources that this document also belongs to.
While \LaTeX{} itself does a very good job at laying out (floating) image files in text documents, \env{musicexamples} actually manages to integrate examples in different forms (floating/non floating, one/multi systems, full page) into one contigious list.

\paragraph{lilypond-book} is part of the LilyPond distribution.
It takes a different approach than \env{musicexamples}.
While this works with image files (that can be generated with \emph{any} program, \env{lilypond-book} lets you enter actual LilyPond code in the \LaTeX{} document.
Both approaches have their pros and cons, but \env{lilypond-book} is definitely an interesting way if you want to store your music example sources directly along with the text source.

\paragraph{lilyglyphs} is also part of the \openlilylib{} family and allows you include notational elements from LilyPond in the continuous text of \LaTeX{} documents.
Different from any other solution I found it can provide \emph{any} notation that can be created with LilyPond, and it scales well and automatically with the text font size.

\paragraph{riemann} is unfortunately no more than a plan and a desideratum so far.
But (as I will need that functionality myself soon) I'm confident that it will actually emerge to being useful.
It will provide commands to typeset functional analysis symbols.

\bigskip
\noindent I will reconsider these packages in more detail in the last section of the LilyPond chapter.

\subsection*{Getting Stuff into and out of \LaTeX}
One important issue I haven't touched yet is the exchange of data between \LaTeX and other programs.
Maybe you'll soon be convinced and love to author everything with \LaTeX{} -- if not now then after having read the chapter about Git \dots{} -- just as I do now most of the time.
But you will sooner or later run into the situation of having to convert material in one direction or the other.
Fortunately this works in both directions, although you always have to expect some manual configuration or retouching.
To be honest, I can't reliably tell you too much about it because I've been in the lucky situation that I could deliver everything as \textsc{pdf} files since I started using \LaTeX.

Maybe the most common situation is to import documents from word processors that are still present on your disk or that you get from other authors.
While it is possible (but often cumbersome) to copy the plain content via the clipboard there are export filters and/or converters available for both Microsoft Word and Open/LibreOffice%
\footnote{For example, latex2writer (\url{http://writer2latex.sourceforge.net/}) is a highly configurable export filter for OOo}.
They will do quite nicely and especially handle items like tables or images, but depending on the structure of your input documents you may have to define the conversion process on a more or less detailed level.
There are also solutions to convert Markdown or \textsc{html} documents to \LaTeX, with some additional work you will also be able to convert spread sheets to \LaTeX{} tables.
Basically you will manage to convert \emph{any} material to \LaTeX{} documents, and if there should be any loss on the way it is because there actually \emph{is} a conceptual incompatibility between your material and \LaTeX.

The other way round is more frustrating -- not from the perspective of the workflow but because of the declining output quality \dots{}
Quite often you will have to deliver your texts as Word documents because the publisher can't handle anything else, or you want or have to collaborate with people who can't edit \LaTeX{} files.
For these cases there are several solutions around, \LaTeX{} export filters, standalone converters%
\footnote{Take \url{http://sourceforge.net/projects/latex2rtf} as a converter to \textsc{RTF}, which can be opened by most word processors}
or Word/OpenOffice import filters.
The already mentioned \package{pandoc} tool can also convert \LaTeX{} documents to several other formats.
But apart from having to live with the inferior typesetting quality of most other programs you will have to consider that word processors only can handle parts of \LaTeX's power.
For example you can't expect any off-the-shelf converter to correctly deal with custom environments or commands that do fancy things with arguments.
But you can expect them to correctly convert default text with formattings, tables, figures, cross-references and bibliography.
So if you know you have to deliver a word processor document to the publisher you still can benefit from the plain text approach and author your document with \LaTeX, but you should have the final destination in mind right from the start -- then you should be ok.

\todo{Is it possible to (easily) convert a latex document to InDesign or QuarkXPress?}

\todo{Ask for feedback if the conversion is actually working without too much hassles}


\chapter{LilyPond}
As the other main cornerstone in creating music-related documents we have the topic of musical \emph{engraving} or \emph{notation}.
And in the current context of plain text workflows we have something like the “\LaTeX” of musical engraving: \emph{GNU LilyPond}%
\footnote{\url{http://www.lilypond.org}}.
This characterization is not only true because LilyPond uses a plain text input language that is quite similar to \LaTeX, but it originally even used \TeX{} as its typesetting engine until the developers realized that this stretched the differences between typesetting text and engraving music too far.

The origin of LilyPond's development is located “on stage”: Musicians who also are good programmers were tired by the numerous skinnyly looking computer-generated scores and parts they were obliged to read day by day.
They decided to write an engraving software that was able to create both \emph{soulful} and \emph{easily readable} sheet music.
The idea was -- similar to that of \LaTeX{} -- to teach the software the golden rules of (classical handcrafted) engraving instead of having the user to learn them (usually only rudimentarily) and apply them by trial\,\&\,error.
And in my opinion this was a brilliant decision, because especially the out-of-the-box results (which probably 80 \% of musical scores are) clearly outperform those of any other notation software I know.
One of the fundamental reasons for this actually is that LilyPond works by compiling source files -- I'll reason a little bit on that in the next section%
\footnote{Now would be a good point to read some of the basic information from LilyPond's home page, for example the essay on computer based engraving: \url{http://www.lilypond.org/essay.html}}.

\section*{Consequences of the Plain Text Approach}
It may look strange to edit musical scores by writing text in a plain text file.
In fact this seems even more strange than with editing text documents.
One wouldn't edit or create \emph{images} by writing text, isn't it?
And one would equally consider it “natural” to edit scores in a graphical, \textsc{wysiwyg} way, entering items with e.\,g. a (piano) keyboard and then moving them around on the screen with a mouse.

But it actually is quite different:
First of all, engraving music is about entering \emph{content}, while the graphical distributing of objects on the page is a secondary (although extremely important) element.
While graphical score editors somehow resemble a sketchbook where you can directly enter ideas without really thinking about the final result.
These tools are conceptually better suited for \emph{writing} music while LilyPond is actually\emph{engraving} music.
This is basically the same distinction as with \emph{writing} documents in a word processor or \emph{typesetting} it with \LaTeX.
Using \LaTeX{} compares to metal type just as using LilyPond compares to plate engraving.

One fundamental drawback that all \textsc{wysiwyg} programs share -- in terms of output quality -- is that they are forced to make their layout decisions \emph{on-the-fly}, possibly instantly.
This either makes the decisions quite short-sighted (i.\,e.\ they can't take the context of the whole document into account), or it may make the program choke with constant iterations, say, of the page breaking.
LilyPond on the other hand (as well as \LaTeX) takes the complete input, “takes its time” to digest it and processes it to a firm representation of the \emph{musical meaning} before actually making its layout decisions in the context of the whole score.
This takes some time (which may be considerable, depending on the complexity and length of the score and the power of your computer), but it usually creates much better default results than that of \textsc{wysiwyg} programs, leaving significantly less work for manual improvements.
LilyPond isn't perfect, but the developers are working hard trying to reduce the number of manual interventions needed -- instead of creating a nice and cozy user interface to actually produce these interventions.
As a personal opinion based on experience I'd say that the results of a score with only the bare music entered, i.\,e. without any manual intervention, is nearly always very readable.
When typesetting scores only for my personal use on stage, there is rarely any need for manual improvement.
I barely encounter notational flaws that actually affect the useability of the score for performance -- a situation I suffered regularely when still using \textsc{wysiwyg} notation software.

\subsection*{Representation of music in the source file}
On the website you can find a nice multicolored introduction to LilyPond's text file based design (\url{http://www.lilypond.org/text-input.html}).
Therefore I can keep this description to a minimum.

At the most basic level you write notes as letters with numbers for their duration and special modifiers for their octavation: \verb+{ c4 d' e, f g1 }+, where the 4 stands for a crotchet, no number means the previous duration, and 1 is a whole note; single quotes are an octave higher, commas an octave lower.
Any music in LilyPond is within the context of a \emph{music expression} which is enclosed by curly braces.
If you'd just compile this example in a file, LilyPond would implicitly complete it with the necessary infrastructure (which in this case would be one staff with a \lilyTimeC time signature, a treble clef and the C major key) and create a score context from this tiny fragment.
But of course you can also explicitely define the staff and score contexts in which your music should be interpreted, which will be necessary if you write more complex scores.
If you do so you could enter the musical content directly within the score context, but I'd strongly suggest right from the start making use of a feature of LilyPond's input language: \emph{variables}.
You can store a music expression (with its curly braces) in a named variable that you can later reference in the score:

\begin{lstlisting}[numbers=left,language={[LaTeX]TeX}]
% Define a music variable
melody = \relative c' {
  c4 d e f g1
}

% Create a score block
\score {
  \new Staff = "Vocals" {
    \melody
  }
}
\end{lstlisting}
First we define a variable that we can later reference by \cmd{melody}.
The \cmd{relative} clause that precedes the music expression indicates that the following pitches are considered relatively to the preceding ones, starting with \texttt{c'}%
\footnote{The alternative would be absolute note entry in which you specify the octave with each pitch individually}.
This way the item to be entered in the score (in line 9) can be extremely short, independently of the length and complexity of the music.

What you can see in the example is that within a \cmd{score \{ \}} block we define a staff with a name, which includes the music variable.
By extending this you can define a score setup with arbitrary complexity, which is usually quite straightforward but allows you very detailed control if you wish.

\subsection*{Advantages of the Plain Text Files}
\paragraph{Comments} 
In the previous example you have also seen the possibility to enter \emph{comments} in the source file.
This is a very useful tool as it allows you to add descriptions right beside the content they belong to -- critical remarks, \textsc{todo} reminders, technical comments or whatever you can think of.
They are just (persitently) there without being intrusive.

At the time of writing this is still something for the future, but there are concrete plans to develop a tool called \package{lilypond-doc} (also in the context of \openlilylib). 
This tool will be a \emph{significant} enhancement of LilyPond's potential for (scholarly) editions.
While the original motivation for this is to document LilyPond files from a more technical perspective%
\footnote{mainly to create a reference of all variables and functions that are available to be used}
its equally important purpose will be to create documentation of the contents.
While initially entering the music one will be able to enter special comments, for example with questions on the critical revision, but also things like \textsc{todo} items and other technical questions.
\package{lilypond-doc} will then process them and create a reference document with all these comments, sorted by bar numbers and with links to the respective places in the source files.
This way you not only have your \textsc{todo} list at hand but right beside the musical contents where they belong to.
When handling all these questions the comments can continuously be changed to critical remarks, and \package{lilypond-doc} can finally export them to entries for the critical report (be it in \LaTeX, word processor formats, \textsc{html} etc.).
Combined with the potential for collaborative work we'll discuss later this will set LilyPond apart from any other solution one could think of.

\paragraph{Variables}
Packaging musical expressions in variables isn't only useful to reduce the complexity of the score block but serves many more goals.
It is a way for transparently and robustly store, use \emph{and reuse} blocks of music.
Reusing music is very useful, not only for the -- admittedly quite specific -- case of musical snippets or patterns, but also for the fundamental handling of the needs of musical engraving.
You never have to \emph{extract parts} from a score, instead you write down the music and use the variables to construct different scores from it (e.\,g. the conductor's score and the instrumental parts).
As you have seen in the previous example you will put the variable with the music definition inside the definition of a score -- and you can simply put it inside the definition of another score to get another type of output.
The same is true for transpositions: 
If you need a transposition you don't have to make a copy of the music but just use the variable and apply the transposition.
Depending on the task at hand you may apply it to an individual variable, a part (or staff) or the complete score.
And you always know exactly where your music is defined in the source file -- all in all this is a very robust approach.

Another very handy property of variables is that you can \emph{redefine} them.
One common application of this is a construction like this:

\begin{lstlisting}[language={[LaTeX]{TeX}}]
origLinebreak = {
  \break
}

%\origLinebreak = {}
\end{lstlisting}

This defines a new command \cmd{origLinebreak} that you can use to indicate line breaks in your printed model.
This way the line breaks of your score will match the one from your model, which usually is a great simplification during note entry.
When you are finished entering the music you can simply remove the comment \texttt{\%}sign before the second definition which then will overwrite the first one with an empty command -- the \cmd{origLinebreak} entries in your music definition will have no effect anymore, and LilyPond can decide upon the layout by itself.
And as nice side-effect you have the original line breaks documented in the source file, which may be a welcome benefit depending on the nature of your project.

\paragraph{Style Sheets and Includes}
Page layout and header information are defined in \cmd{paper\{ \}} and \cmd{header\{ \}} blocks.
In addition to the usual definitions of paper size and margins you can tell LilyPond to justify the score vertically and horizontally or leave it ragged, force the overall number of pages or systems per page, and you have fine grained control over many layout parameters if you should need to tweak them.

Just as you can do with programming languages you don't have to write such definitions in your main input file but you can also put it in a separate file and \cmd{include} this.
The main advantage of this is that you can \emph{reuse} the definitions for any number of files, so you can easily set up a project wide or even a global configuration.
All scores in the project (e.\,g. all songs in a song book or all examples in a musicological book) will have a consistent appearance, and if you want to change that you can do it centrally in one place.

You can even provide alternative layout definitions and switch them easily by \emph{commenting} out the include clause:

\begin{lstlisting}[language={[LaTeX]{TeX}}]
\include "score-layout.ily"
%\include "part-layout.ily"
\end{lstlisting}

These lines in a main input file allow you to switch between two layouts on a per-score basis.
But you can also make use of the fact that you can cascade includes.
If you had entered the previous example in a file \texttt{layout.ily} and include the following in each input file:

\begin{lstlisting}[language={[LaTeX]{TeX}}]
\include "layout.ily"
\end{lstlisting}

\noindent then you can switch the layout project-wide and recompile all scores with the new layout.
It is even possible to define filename suffixes within the style sheet files so that you don't overwrite your files but have \texttt{-score.pdf} and \texttt{-part.pdf} files alongside.

But you can also make use of cascading includes in another way: you can modify their content.
Say you have an include file like the following \texttt{layout.ily}

\begin{lstlisting}[language={[LaTeX]{TeX}}]
\header{
  title = "Sonata"
  composer = "Franz Schubert"
}
\end{lstlisting}

\noindent this would effective project-wide.
But if you write 

\begin{lstlisting}[language={[LaTeX]{TeX}}]
\include "layout.ily"

\header{
  subtitle = "(unfinished)
  composer = "Franz Schubert (doubtful)"
}
\end{lstlisting}

\noindent in your main input file you can change the header for the current file only:
This adds one field (subtitle) and overwrites the composer field for the current score only, while leaving the included title field untouched.

With this -- and a few other techniques -- you can rather easily create a sophisticated set-up of global, project-wide and individual styles.
For example I have a global library with some settings that I always use by default (including for example text font selections), and style sheets for specific score types (e.\,g. songs or four-piano scores) that I can simply \cmd{include}.
If I want to change some settings for a single project I can overwrite the elements that I want and still keep the link to the base style sheets, which is quite different from merely copying a template.
This is a really robust approach just like for example the design of a web site using \textsc{css}%
\footnote{Cascading Style Sheets, \url{http://en.wikipedia.org/wiki/Cascading_Style_Sheets}},
with nothing hidden in “settings” dialogs and everything transparently accessible.

\paragraph{Robust source code}
As you have already seen \emph{every} aspect of musical content and notation is written down in the source files.
Of course this can get quite complex when the music gets complex, for example with articulations, dynamics, elements like slurs or text spanners, and especially when manual intervention in the layout decisions have to be made.
But I consider this definitely an advantage because of being so explicit.
If I write \cmd{slurUp} to tell LilyPond to print a slur above the notes or \cmd{noBeam} to force the breaking of a beam there is no way for ambiguity.
Way back when I was using (admittedly now outdated) \textsc{wysiwyg} notation software I constantly suffered from having half of my manual decisions reverted when hitting “Update layout” \dots

\todo{Do I need examples here? Or can this wait until the “Working with LilyPond” section?}

\paragraph{Algorithmic notation}
\todo{better title!}
Plain text files are perfect for being accessed and processed by computer programs.
Maybe you will never make use of that, but it's a fascinating possibility you will probably never get from graphical programs.
Generating, interpreting and processing text files are the very basic capabilities of practically every programming language.
So you can very easily create algorithmic processes to generate music input for LilyPond (for example I once realized a complete rendering of a serial composition), you might write an analysis tool or apply contrapuntal operations on music snippets.
As the access to plain text is so straightforward the only limits are your fantasy and your programming capabilites:
From the technical point of view it would be a breeze to create a script that downloads the daily weather data from an internet server, algorithmically composes a movement of your ground-breaking “Weather Suite” and posts the pdf to your Facebook wall%
\footnote{The aesthetical value of this work in progress would be debatable, though}.

Another -- real-world -- example is \package{lilyglyphs}, a package that allows to include LilyPond's notational elements in \LaTeX{} documents (see \fref{subsec:lilyglyphs}).
To extend the collection of available symbols one has to create a score file for each symbol.
In order to streamline this process I created a script that generates the complete LilyPond input file from a very short template file, invokes lilypond to compile it, and finally generates the \LaTeX{} code that is then needed to include the symbol in the text document.

\paragraph{Profound notion of the musical structure}
As a result from the explicit nature of the input source and the non-realtime behaviour LilyPond is able to get a very good idea of the syntactical structure of the music before bothering with layout decisions.
While you may not notice this every day it is reassuring that you practically can't disturb LilyPond with difficult or complex (except for plainly \emph{wrong}) input%
\footnote{with maybe the exception of one long-standing bug with the synchronization of grace notes in some contexts. This is quite annoying but fortunately there is a simple workaround available.}.
This is especially impressive with complex timing situations.
You can notate arbitrarily complex nested tuplets without making LilyPond sweat.
One of my first scores with LilyPond was a fraction of a piano part of a composition by Brian Ferneyhough that I couldn't read from the material the ensemble had provided me with -- the result was \emph{very} convincing, and I would love to include the example here if it weren't for copyright considerations.
And it is similarly easy and robust to enter any form of polymetric constellation%
\footnote{For some examples see\\ \url{http://www.lilypond.org/doc/v2.16/Documentation/notation/displaying-rhythms.html\#polymetric-notation}}.

\subsection*{Features for Musicologists and Teachers}

One very important topic has already been discussed along with the plain text driven advantages, but LilyPond offers more interesting features for musicologists and teachers.

Empty spaces (for tests)\\
Schenker graphs\\
Annotations\\
More? This has to be considered very carefully\\
\todo{Review the docs for examples}

\section*{Working with LilyPond}
\subsection*{Syntax continued}
To give you kind of an impression how it is to work with LilyPond I'll provide you (only) a few examples.
Of course this can't even be considered scratching the surface, but if I'd want to do more I could start writing a book.

Earlier you have seen how pitches and durations are represented in LilyPond input files.
Now I'll present you a few snippets of notation with increasing complexity, just to help you get an idea how it “feels” working with LilyPond.
In real scores this can admittedly sum up to a quite complex overall impression, but it's much easier if you keep in mind that this complexity is built on simple building blocks.

\todo{Examples:}
\begin{itemize*}
\item Articulations
\item Dynamics and markup (with direction indicators)
\item manual beams and slurs (with direction indicators)
\item property overrides
\item \cmd{shape} (with \cmd{displayControlPoints} on)
\item Extending with Scheme\\
compare to scripting language of finale
\end{itemize*}

\subsection*{Editing Environments}
As with \LaTeX{} you have plain text input files for LilyPond that can essentially be edited with \emph{any} text editor.
But of course it isn't quite desirable to use a \emph{notepad} style application for more than a few notes' worth.
What you'd want is at least an editor with syntax highlighting.
LilyPond syntax isn't a common language so few editors will directly support it, but if you find a decent editor with \LaTeX{} support this will already help you a lot.
The default text editor of the Linux Gnome desktop, \emph{gedit}, does this for example, \emph{TextEdit} on Mac OS X too (as far as I know).
For Windows there are plenty of enhanced editors too, but I can't tell you more about it.

\todo{(free) editors for KDE, Mac, Win}

But you'll be definitely better off with an editor with explicit LilyPond support, which you'll fortunately get for any operating system%
\footnote{See also \url{http://www.lilypond.org/easier-editing.html}}.
Depending on your preferences there are two major editors to recommend: \emph{Frescobaldi} and \emph{jEdit} (with \emph{LilyPondTool}).
\emph{jEdit} is a Java based versatile programmer's editor, and \emph{LilyPondTool} is a dedicated plugin with many useful functions.
If you need a multi-purpose editor or already are used to jEdit this may be the solution for you.
\emph{Frescobaldi} is a dedicated LilyPond editor which (in my opinion) already offers the best possible way to work with LilyPond files, and it is evolving in a quite promising way.
So if you don't have strong preferences for one of the other editors this is what you should start with.

\todo{Add all necessary links}

\emph{emacs} and \emph{vim} also have LilyPond modes to support you -- but if you actually use them already you'll probably not read this paper anyway, and if you don't use them yet they are hardly recommendable for you.
Finally there is \emph{Denemo}, a graphical \emph{front end} for LilyPond.
This strives to be a user interface for the note entry, without trying to do any engraving layout.
So it tries to combine both worlds, the \textsc{gui} and the text file approach.
But in fact it is a \textsc{gui} program where you can enter notes etc.\ in a graphical way and that generates a LilyPond input file from your input.
While this may ease your approach to LilyPond significantly it also limits the flexibility to that possibilities Denemo's programmers have thought of.
As I have got used to editing plain text files I can't really comment on this.

So I'll finally show you a few key elements of \emph{Frescobaldi}, my editor of choice.
Originally it had been based upon \emph{kile}, the main \LaTeX{} editor of \textsc{kde}, a Linux Desktop Environment.
But by now it has completely been rewritten from scratch as a standalone application.

Of course if offers an editor with \emph{syntax highlighting} and \emph{code completion}, making both the reading and writing of LilyPond code as easy as possible.
It also offers other tools that are handy in programmers' editors like automatic \emph{indentation}%
\footnote{Source code is \emph{indented} in most programming languages in order to make the \emph{structure} of the code easier to understand.}, 
\emph{code folding}%
\footnote{Hiding blocks of code to let you concentrate on what you currently work on}
or \emph{bracket matching}%
\footnote{Highlight the matching counterpart of a bracket. 
This makes it easier to pin down mismatches (i.\,e. having written too few or too many brackets)}.
There are dockable tool palettes that enter suitable code by clicking on an image button, document templates and wizards.

An unimpressive yet very useful tool is the \emph{snippets} functionality.
Similar to macros as you may know from office programs they offer the possibility to insert small snippets of code into your document (just to save you repetitive typing of common models) -- but it also allows to execute arbitrary code in the Python programming language, if you can write that or know someone who does.
This way you could apply arbitrarily complex operations on your music (such as contrapuntal modifications for example), or you could even take selected music, compile it as an excerpt and email the resulting .png file).

But probably the most important feature is Frescobaldi's \emph{Music view} with the integrated \emph{two-way point-and-click} integration.
If you move your text cursor through your document the corresponding items (notes, slurs etc.) in the music view will be highlighted.
And if you click on an item in the music view the text cursor will be placed right at the corresponding entry in the source file (which is opened before if necessary).
This way it is really easy to navigate your source file(s) -- which could admittedly get complex otherwise when editing large and complex scores.

For the future there are plans to enhance the music view to allow simple editing with the mouse that automatically inserts the corresponding source code in the editor.
If the developer of Frescobaldi manages to add such functionality it would turn the LilyPond experience into something practically as comfortable as working with \textsc{wysiwyg} editors -- with all the added benefits from the plain text approach!

\subsection*{Getting Music In and Out of LilyPond}

\section*{Integrating Text and Music}

\subsection*{Music Examples in Text Documents}
Of course you can always embed images in text documents, this isn't different if you work with \LaTeX{} or a word processor.
But there are a few dedicated tools that aid you in this process, I will specifically talk about \package{lilypond-book} and \package{musicexamples}.

\subsubsection{lilypond-book}

\package{lilypond-book} is a script that is part of the LilyPond distribution.
It allows you to embed LilyPond source code directly in \LaTeX{} documents.
It works as a preprocessor by processing your \LaTeX{} source file, generating all necessary LilyPond examples and including them as images in a copy of your source file.
Advantages of this approach are that you can store the code for your musicexamples right where it is referenced from, and that \package{lilypond-book} takes care of a few things for you: It adapts the linewidth of the examples to that of the text and makes sure the examples are always up to date (it recompiles them if necessary).
The (possible) downside of the approach is that \package{lilypond-book} creates a lot of intermediate files that may clutter your working directory.
Usually you will place these in a dedicated subdirectory, but this may cause difficulties if you use relative paths to included objects (other images etc.).
As far as I can see people who use \package{lilypond-book} a lot have to do extra work to set up these things, possibly with some helper scripts, but in situations where you have to deal with large numbers of small examples (as you can see in LilyPond's extensive documentation) you won't find any other solution that can help you so much to keep your music examples in order.

\subsubsection{musicexamples}
Another way to embed music examples in \LaTeX{} documents is \package{musicexamples}, a package that is part of \openlilylib%
\footnote{\url{http://www.openlilylib.org/musicexamples}}.
Originally started as an alternative approach to \package{lilypond-book} it can actually work together with it quite well.
\package{musicexamples} provides environments and commands to include and manage music examples in \LaTeX{} documents.
There is support for floating and non-floating environments, i.\,e.\ you can place them immediately where you embed them in the document or you can allow \LaTeX{} to place them according to its page breaking algorithms%
\footnote{For people coming from word processors this is usually somewhat difficult to get used to.
But it is actually good typesetting practice to let figures, tables etc.\ “float”.}.
You can enter single-line or multi-line examples, with the multi-line ones being able to be split on several pages (if you provide images for the individual systems, of course).
Finally you can also print full-page examples, with special support for examples starting on odd or even pages (you can force example to start at the next odd or even page).
All examples in a document share the same counter and can be exported to a contigious list of music examples.

It is possible to use \emph{any} images for your music examples, but there is special support for using LilyPond (of course).
There are include files that take care of formatting and compiling your examples to the right files to be included in the text document.
And there will be helper scripts that keep the music examples up to date (and conditionally recompile missing music example files).

Instead of existing image files (LilyPond generated or not) you can equally embed LilyPond code with \package{lilypond-book} and benefit from both approaches:
\package{lilypond-book}s in-place example code and \package{musicexamples}' beautiful layout and example management.

\bigskip
\todo{screenshots, maybe include musicexamples' example document?}

\subsubsection*{OOoLilypond}
\todo{OOoLilypond}

\subsection*{lilyglyphs}
\label{subsec:lilyglyphs}
Another member of our family of resources is \lilyglyphs[scale=1.1].
This package allows to include LilyPond's notational elements in the continuous text of \LaTeX{} documents.
This is significantly different from entering music examples as it will embed them as characters, like \lilyDynamics{mf} for example.
The main advantage of this package over any other solution I know of is that these elements are readily available, scale well with the surrounding text size, and that you can realize virtually anything you can do with LilyPond.

Elements that are part of LilyPond's OpenType font can be accessed through predefined commands (the above example was written \cmd{lilyDynamics\{mf\}}) or -- if there isn't a predefined command yet -- through their glyph names from the font, like this \lilyGlyph[scale=1, raise=0.75]{clefs.mensural.c} mensural clef \cmd{lilyGlyph{\{clefs.mensural.c\}}}.

For elements that aren't part of the OpenType font and that are normally drawn by LilyPond \lilyglyphs  uses small images that have been generated with LilyPond.
The use is identical if there are predefined commands like this \crotchet[scale=1.1] \cmd{crotchet}.
If there isn't a predefined command or if you need a very non-standard symbol, \package{musicexamples} assists you in creating your own predefined commands with a relatively easy to use interface:
You will provide a small “template file”, and a helper script will create a LilyPond input file, compile it, manage the files and generate the necessary \LaTeX{} command.
This way you can include arbitrary notational elements as characters in your text documents, with perfect control over the scaling and positioning.

\chapter{Git}
Now that we have covered%
\footnote{Well, \emph{scratched} would seem more appropriate}
some of the concepts and possibilities emerging from working with plain text files we will finally be heading towards the most important aspect of it all: \emph{collaborative editing}.
The ambiguity of the word is intended -- I'm talking about editing (or more generally working on/with) musical works in a collaborative and social way, and I'm talking of simultaneously editing source files.
Earlier in \fref{sec:intro-versioning} I have introduced some key concepts of versioning with Git: \emph{diffs}, \emph{commits}, \emph{history}, and the \emph{working tree}.
I'll give you short reminders while also providing a slightly new perspective on them based on what we saw in the meantime.

\medskip
\emph{Diffs} are the changesets that show you exactly what has been changed between one state of your document and another.
This doesn't necessarily mean the difference between two adjacent states of the files.
You may also create a diff between two arbitrary states of your project, which allows you to review the sum of all changes done to a specific chapter, for example.

\medskip
\emph{Commits} are something like “save points” in your project.
Whenever you have completed any coherent set of edits you should “commit” them.
The commit will then contain the diff between the current state of the working directory and the last stored state, and it will contain a reference to the previous (or “parent”) commit.
This is a nice feature because with compiled documents you will save much more often than with \textsc{wysiwyg} documents.
If you aren't happy with the work of your day you can't just hit “close” without saving to discard everything because everything has already been saved to disk multiple times.
With versioning the commit takes the place of saving your work at the end of the day.
A commit can also contain changes to more than one file and therefore connect related work.
But if you have done changes to more than one topic (e.\,g.\ edited a document and updated a style sheet) you have fine-grained control over what you put into that commit.
This is achieved by \emph{staging} contents, and you can stage not only complete files but individual lines within files.
This way you can have really detailed documentation of your work or the stages it has been in.

To give an idea why this can be useful take a LilyPond score as an example.
Say you are editing a historical manuscript that exposes two stages of work (usually these are discernible through different inks or the like).
You may start with entering the plain notes and rhythms that make up the initial stage.
When you're finished with that you create a \emph{tag}, which is a special commit to be used like a bookmark.
Retracing the steps of the composer you continue to update the score with the composer's secondary entries and enter another tag.
Now you can simply \emph{check out} the alternative tags (or any other commit) and have your project reflect the respective states, i.\,e.? you can alternatingly compile the two versions of the score.
When you are going to publish that score you will probably tweak it to perfection, but with good commits and tags you can always keep the untouched version without manual modifications.
This can prove useful if you review the score with newer versions of LilyPond later on.
Of course this is only \emph{one} example of making use of Git techniques -- in real life there are many more \dots

\medskip
The chain of commits and their parents up to an initial first commit make up the repository's \emph{history.}
This history can be inspected as already described, but it can also be \emph{changed} (but with great care).
As I said you can understand it as an unlimited undo/redo system that can't just go back and forth on the timeline but also can pick single changes.
For example you could undo a specific commit from any point in history, or you could undo everything up to a certain point \emph{except} one specific changeset.

As a commit doesn't know much more than its changeset and the reference to its parent it is even possible to apply a commit to another commit than its original parent, thus changing the order of history in (nearly) arbitrary manner.
But as these are really advanced topics I won't go into more detail in this paper.

\medskip
There is one more technique which hasn't been mentioned so far but which is also very powerful: \emph{branching}.
Branches are somewhat like independent workspaces that you can use to separate independent working processes.
By default all work happens in the context of the “master” branch.
You can now create a new branch from that and work on that without affecting the master branch.
In this context you can for example work on things that could temporarily break something -- such as a new layout style sheet or simply a thought experiment that might also be nonsense.
Just like \emph{checking out} commits one can switch between branches by checking them out.
Git will then set your working tree to the state of the given branch so checking out the master branch will let all of your fragmentary edits seem to disappear.
But of course checking out your \emph{feature branch} will give them back to you for further improvement.
If work is finished and satisfactory the feature branch is \emph{merged into master} and incorporated in the official work.
Otherwise the branch is simply dropped and your main line of work is untouched.

One can design more or less sophisticated workflows around Git branches -- but this mainly affects the next section:

\todo{Where to enter history graphs?}

\section{Collaboration with Git}
This is where we \emph{really} enter new grounds in our scholarly or artistic workflows.
Using plain text files and version control enables us to benefit from techniques and strategies that have been invented for and improved for decades in software development%
\footnote{In fact Git has been originally written to manage the development of the Linux kernel.}.
And the key concept in this regard is \emph{collaboration}.
Software is mostly developed by teams or even large communities.
Therefore it is crucial to have tools that manage the contribution of multiple authors to the code base, and distributed version control is one very good tool for that.

\subsection*{Traditional approaches}
Let me begin with describing traditional approaches (“traditional” being of course quite relative).
The most basic way to collaborate on a project is to exchange ideas personally, by phone or by email, and have one person edit the document.
This way the document is guaranteed to be in a consistent state, but the workflow isn't really practical.

\medskip
A document may be \emph{shared by email} in order to let a collaborator apply edits to it.
This \emph{may} work if there is only a very small number of people involved (usually just two).
But it adds complexity.
What to do with the file returned by email?
Rename it (with date and time for example) and add a second copy, or overwrite the previous version that had been sent to the other?

Office programs offer functionality to “record changes”.
While this is useful to visualize the different collaborators' contributions it doesn't really solve the complexity of shared documents.
What if A sends B a file, B modifies and returns the file, but A has done further changes in the meantime?
You can't just use the file but have to save two separate copies and compare them manually!
Now try to figure out how probable it is to run into such conflicts with more than two participants \dots

\medskip
Storing files in a “cloud” based location like a Dropbox folder improves the situation in that there isn't the need anymore to maintain multiple copies of the files (or if there are they are transparently managed by the service provider).
But you still have to avoid parallel modification of one file by different people.
If you run into that situation you still have to fiddle around manually to recover.
What if you are offline for a while, taking a laptop with you on vacation?
Would you ask the others not to touch any files you \emph{might} be working at during your holidays?
Or would you just hope that nobody else touches the same files as you?

I think it is clear that both methods have their severe drawbacks, and especially they become virtually unmanageable when there are more than two or three participants to be coordinated.


\subsection*{“Distributed Version Control”}
Version controlling source files wouldn't be half as effective (and half as fun) if you could only work on your Git repository as I have described so far.
But version control has been designed to be used for collaboration right from the start.
Git for example has been created to manage the development of the Linux kernel (the operating system's “heart”), where over the last years nearly 10.000 developers have supplied several hundreds of thousand commits.

\medskip
The heart of a distributed working set-up is a shared repository located at a central server that is accessible to all contributors.
This may be on a server of your local network or at a dedicated service provider.
The latter offer simple and powerful solutions with intuitive web interfaces while managing Git on the own server requires some knowlegde.
But depending on the nature of your project you may have to consider privacy issues.
While most providers offer private as well as public repositories, but in the end you \emph{are} hosting your code on a different company's server.

What sets a \emph{Distributed Version Control System} like Git apart from \emph{Centralized} ones like CVS or Subversion is the fact that \emph{every} collaborator has a complete copy of the repository's content.
One only interacts with the shared repository whenever one wants to \emph{push} his work to the server or \emph{pulls} changes to the local repository that have been done by others.
Between one can work for days or even weeks without bothering about the shared repository.
In the meantime one can commit as often as necessary to reflect the structure of one's progress.
As I have pointed out one doesn't have to lock any files in order to be able to edit them.
Due to the line-by-line comparison the risk of running into conflicts is rather small.
Possible causes may be when two collaborators accidentally have changed the same line in the source code, or one author changes lines in a file that an other has deleted in the meantime (which is something that shouldn't happen anyway in a well-organized team).
And if there actually should be conflicts they usually are quite easy to resolve:
You are presented with the two conflicting versions and can decide which one to use (as you do this within the document you are free to merge material from both versions or even write the offending section completely new).
I for example work on different computers and therefore have to push and pull my changes around on a daily basis (which I had done by syncing through a \textsc{usb }stick earlier).
When writing this paper I forgot to push my work from one day to the server and left that computer for over week, working on a different \textsc{pc} for that time.
When I finally got back to the first workplace I merged the different versions and was confronted with only one conflicting paragraph.

The same is true when several participants work on the same project or score.
As long as there aren't any conflicting changes in the same line of source code everything works smoothly.
In a useable set-up one line of source code corresponds to one measure of music in one part of a score, sometimes even less.
In text documents this corresponds to one sentence (or other conceptual entity like a footnote).
It can actually happen if one author makes corrections to the music while the other fine-tunes the layout decisions of the same part -- so this should better be avoided.
But even if this should result in conflicts this is worlds apart from the situation one would have with one shared document that is exchanged by email -- one wouldn't even have dared to think about the option of editing a score in parallel.

\medskip
There is one other important point of collaborating with Git which I'm not sure has been stressed enough so far.
As Git stores the \emph{difference} between two states in its commits it can also \emph{display} this difference -- in other words, I can exactly see what a collaborator has modified.

\medskip
\todo{Screenshots (w. comments) of a few commits: change a single note | complex tweak | changeset across files}

\medskip
There is also the other way round: Git has a \emph{blame} command which can be used to annotate a file with the authors who have last changed each line in the file

\todo{Screenshot}

\chapter{Conclusion}
Now it's time for a summary, starting with a short list of key advantages and problems of my suggested tools, followed by a not so short description of a few real world scenarios.

\paragraph*{Advantages}
Version Control offers an unlimited and extremely flexible undo/redo mechanism through its \emph{history}.
One can even selectively undo a partial commit from history.

\emph{Distributed} Version Control offers unparalleled potential for working together on projects, small teams of two contributors as well as an “open source” crowd.

The plain text source files allow creative access modes that are unimaginable with binary file formats.

\paragraph*{Difficulties}
The learning curve is steep and/or long (or even both), this can't be denied.
Working with these tools requires diving into topics that probably are completely new ground for most of us.
But I'm sure it is definitely worth the effort on the long run.

Version control is quite restricted to text file formats.
Working with binary files (which one can hardly avoid, take image or other media files as an example) requires special considerations.
While this is actually possible without substantial problems it just adds complexity.

\paragraph*{Data Exchange}
It is quite straightforward to import existing text documents into \LaTeX, and it is also possible to export \LaTeX{} to rtf documents, although one shouldn't have made use of options that a usual word processor can't handle.

There are several ways to get existing music into LilyPond, the rather generic one through the MusicXML language (which many other programs can export), and the use of a few other notation programs that can export to LilyPond file format.

The only real drawback from my perspective is the lack of the possibility (so far) to export music from LilyPond to other formats than the intended graphical output formats.
This is actually a major annoyance because there still are many recipients (i.\,e.\ publishers) who will only accept files in the format of one of the two leading proprietary notation software packages.
As it wouldn't be actually very hard to implement an export to MusicXML (which would lack LilyPond's advanced layout decisions but would make the musical content available to further editing in other programs) I can only hope that this will be supported in the foreseeable future.

\subsection*{Use cases}

\paragraph*{Scholarly edition}
This is what I actually experienced recently -- and what I definitely don't want to miss anymore.
There are several steps in preparing a scholarly edition, which are partly interdependent and are partly distributed between different team members.
\begin{itemize*}
\item Entering the music
\item Setting up the score layout and the style sheets
\item Proof-reading the music
\item Scholarly revision
\item Fine-tuning the engraving
\item Authoring critical reports
\item Layout of the main volume and prepress
\end{itemize*}
All of these steps can be done within one code base.
While it would traditionally also be done in one file the major difference is that the code base is shared and continuously accessible by everybody, the single score file can only be shared consecutively, with complicated and risky workflows to avoid unrecoverable conflicts.
The technical infrastructure doesn't impose any restrictions on the workflow and order of the steps beyond what is immanent in the task (it doesn't make sense for example to fine-tune the engraving while there are still revisions in process that might change the content).
When an editor finds an error just before the edition is sent to the printer he may simply correct it \emph{in the shared code base}, and the engraver can immediately check for side-effects and fix these if necessary.

\paragraph*{Book preparation}
The same is true for the preparation of books, and of compilation books from more than one author in particular.
All collaborators can seamlessly work together in a shared code base: the author(s), editors, typesetters, and maybe additional specialists preparing figures or music examples.
A collaborative set-up provides for an efficient workflow between an author and his editor, and it can be particularly useful when proof-reading or documents or polishing them linguistically with many assistants.

\paragraph*{“Crowd Editing”}
A last use case is something that isn't really common yet because it can only be inspired by the use of workflows that are driven by version control.
With the capability to manage contributions by a (practically) unlimited number of participants it is possible to create musical scores with a large community.
This way the workload can be “clustered” among a potentially great number of people, each one according to his capabilities and special knowledge (about specific instruments for example), and large quantities of music entered in astonishingly little time.
While this doesn't save actual working hours it can be used to process them in parallel.
Even in a large-scale symphonic score each single part is quite manageable, and if there is one contributor for each part (or better: two contributors for two parts who do a peer-review before submitting) the score should grow rapidly.
There are ideas currently to test this approach in one or more reference projects.

\end{document}