%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                         %
%      This file is part of the 'openLilyLib' library.                    %
%                                ===========                              %
%                                                                         %
%              https://github.com/lilyglyphs/openLilyLib                  %
%                                                                         %
%  Copyright 2012-13 by Urs Liska, lilyglyphs@ursliska.de                 %
%                                                                         %
%  'openLilyLib' is free software: you can redistribute it and/or modify  %
%  it under the terms of the GNU General Public License as published by   %
%  the Free Software Foundation, either version 3 of the License, or      %
%  (at your option) any later version.                                    %
%                                                                         %
%  This program is distributed in the hope that it will be useful,        %
%  but WITHOUT ANY WARRANTY; without even the implied warranty of         %
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the           %
%  GNU General Public License for more details.                           %
%                                                                         %
%  You should have received a copy of the GNU General Public License      %
%  along with this program.  If not, see <http://www.gnu.org/licenses/>.  %
%                                                                         %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../../LilyPond-Tutorials]{subfiles}

\usepackage{fancybox}
\RequirePackage{multicol}

\begin{document}
\parttitle[Urs Liska]{Editing Musical Documents as Plain Text}
\begin{authorAbstract}{Urs Liska}
Abstract
\end{authorAbstract}

\chapter*{Introduction}
\label{chap:pt_introduction}
This paper discusses an approach to authoring musical documents%
\footnote{i.\,e.\ scores and texts about music}
that is based on editing \emph{plain text files} instead of using graphical \textsc{wysiwyg} software%
\footnote{What You See Is What You Get---such programs provide an editing environment where the document is displayed identically to the way it will be printed.}.
The described concepts, tools, and workflows have significantly changed my life as a document author, and I  wholeheartedly endorse them because I strongly believe in their unique and substantial advantages.

The plain text approach is practically non-existent in the humanist disciplines or in the music business, while being de facto standard in many natural and computer sciences.
Working with plain text based tools indeed requires a certain shift in mind-set for people who aren't already familiar with the corresponding working paradigms.
And it can't be denied that the learning curve is considerable.
But this investment is absolutely justified because on the long run it greatly benefits productivity and offers potentials unimaginable otherwise.
Reading and writing music, playing an instrument, investigating a manuscript source---all this involves a very long and intense learning curve, and we mastered them as a matter of course in order to become the professionals we are.
So why be afraid learning something new?

This paper is focused on scholarly and collaborative workflows, particularly preparing musical editions for publication, because that's my cup or tea.
But most of it will equally apply to creating musical scores or texts about music that have a certain level of complexity.
The described concepts will also prove useful for people who have to deal repeatedly with similar document types, such as presentations, teaching/exam materials, music examples etc.
However I will \emph{not} cover workflows that mainly depend on instant results but don't care about structure or output quality, such as just-in-time arranging or the like.
For such applications plain text tools may not be the appropriate choice.

If you expect an in-depth description or even a guide how to use the mentioned tools you might be disappointed because that's not the intention of this document.
What I hope to give you is a sense of the power that text based approaches can give you.
For this I will discuss the topics mostly from a rather elevated point of view, keeping your exposure to concrete examples at a minimum%
\footnote{with the exception of some intentionally spectacular examples}.
At the end of the text I will direct you to more extensive material that is suitable to get you more intimately acquainted with the relevant concepts and that may actually aid you getting your feet wet with editing plain text files.

The software packages I will introduce you to on the following pages are:
\begin{itemize*}
\item \emph{LilyPond} -- the program that lets you engrave beautiful scores
\item \emph{Git} -- the versioning system that keeps your work under control
\item \emph{\LaTeX} -- the professional typesetting engine for text documents
\end{itemize*}

\chapter{Plain Text Format}
\label{chap:pt_plain-text-format}
Who on earth would voluntarily enter music as a text file?
Aren't these people just nerds who think that only what hurts can be good?
Isn't it \emph{natural} to edit musical scores within a graphical user interface?

Well, when computers became more powerful it was an inevitable development to provide increasingly powerful graphical user interfaces, allowing users to edit any visual aspects of a document visually with a mouse or other pointing device.
This is obviously quick, effective and easy approach.
But considered seriously and open-minded there are lots of reasons why it \emph{is} a good idea to edit and store documents in text files.
Text based work avoids several fundamental problems that other approaches share, and it opens up a whole range of advanced options not imaginable otherwise.
And it is good to know that by now there are editors available that significantly assist you in dealing with text files.

To start getting into the topic I will consider a number of features of working with plain text files.
Mostly this applies equally to text documents and scores, although the emphasis of this paper clearly is on musical engraving.

\section{Transparency and Control}
\label{sec:pt_transparency-and-control}
Have you ever wondered how your notation program internally manages the contents you entered?
Not as a mental exercise but because you had the impression it maliciously made fun of you?
One of the reasons I turned my back on graphical notation programs was my frustration with being completely at the mercy of the software with regard to my personal layout decisions.
I can't recall (and actually don't want to) how often I ran through the loop of
\begin{inparaenum}[1.)]
\item entering music,
\item moving items around ,
\item applying some manual tweaks like flipping stems, breaking beams, suppressing or parenthesizing cautionary accidentals,
\item hitting “Update Layout” and finally
\item tearing my hair out because at least one third of my manual settings mysteriously vanished.
\end{inparaenum}

Maybe my judgment isn't fair because it is based on very outdated software.
Maybe things have improved a lot, but the fundamental fault is still valid: 
I am at the mercy of the software and can't see or control how it represents the content internally.

A friend finally stopped using (a later version of) the same graphical program when he fixed one missing accidental in a score he had earlier tweaked to perfection---and this accidental caused the whole layout to break irreversibly.

Besides this risk of losing work I also can't usually tell how the program interprets my displacements applied through a pointing device.
Are they interpreted as offsets relative to some point on the page, or relative to the original decisions of the program?
Are they measured in fixed units or with some proportional factor?
None of that would be wrong, but I just don't know about it, and it \emph{does} make a difference if the layout changes afterwards for any reason.

\medskip
\todo{Example how this applies to text documents}

\medskip
If I edit a plain text file instead I'm completely in control over all these issues.
If I tell the program to break a beam or to draw a slur above the note it is explicitely and reproducibly defined and readable by anybody.
There is nothing hidden in “settings” dialogs or even unreadably buried somewhere in the file as the result of dragging something with the mouse.
If I manage to break something (which of course happens) I can review what I did, compare to the last working version%
\footnote{See the “version control” \fref{chap:pt_version-control}}
and understand and fix the issue.
With a graphical program my only resort is to “undo” and hope this will fix it \dots

There is a price for this, namely having to enter code by hand and learning how to do that, but it is very rewarding on the long run.
And being in control just \emph{feels} better \dots

\section{Content, Meaning and Appearance}
\label{sec:pt_separation-content-meaning-appearance}
Through the overwhelming presence of \textsc{wysiwyg} applications we have got used to the impression that the \emph{visual appearance} of a document is identical to its \emph{content}.
But this is actually a quite shortsighted assumption.

If you look at that text document:

\begin{center}
\noindent\shadowbox{\parbox{.8\textwidth}{%
\Large \textbf{\textsf{My new chapter}}

\medskip
\normalsize \textbf{\textsf{With a section}}

\medskip
\small This is the \textbf{\textsf{continuous}} text with some \textbf{\textsf{emphasized}} words.}
}\end{center}

\noindent you will notice that there are several parts formatted in sans-serif bold face of different sizes.
You may guess that the author has applied several style sheets to get this appearance, but to verify it you'd actually have to select the texts and look into the corresponding dialogs or toolbox elements.
Only then you can see whether the author manually formatted the text, applied paragraph styles or character styles.
He may even have applied character instead of paragraph styles to format the headings.

The corresponding \LaTeX{} source file would look like:

\begin{lstlisting}[language={[LaTeX]TeX}]
\documentclass{article}
\newcommand{\terminus}{\textbf{\textsf{#1}}}
\begin{document}
    \chapter{My new chapter}
    \section{with a section}
    This is the \terminus{continuous} text with
    some \textbf{\textsf{emphasized}} words.
\end{document}
\end{lstlisting}

While this may look complicated on first sight it actually is much clearer because it distinctly shows you the content and the author's intentions.
The \cmd{documentclass} is something like a document template, but much more powerful%
\footnote{See the \LaTeX{} chapter \fref{chap:pt_latex}}.
\cmd{terminus} is defined as a character style applying bold (“\dots bf” for BoldFace) and sans-serif (“\dots sf” for Sans-Serif) to its content (“\#1”).
Inside the document body (enclosed by the \cmd{begin} and \cmd{end} statements) you can see the \emph{content} along with \emph{semantic markup}.
The two headings use explicit sectioning commands which are (for now) equivalent to paragraph styles.
The two bold words in the text line are formatted differently: 
the first one  is enclosed by our \cmd{terminus\{\}} character style while the second one is manually formatted as bold and sans-serif.
This mixture of formatting techniques is highly disadvised and only used for the sake of the example.
But you may notice that in the plain text file this “problem” is immediately obvious while the graphical program actually hides away such inconsistencies.

\medskip
If we think about musical scores we have to come to a very similar conclusion.
I began this chapter with the rhethorical pretention that it is “natural” to edit a score in a graphical way.
But in fact that's not entirely true because a score isn't a graphical object like a painting
but rather a graphical \emph{representation} of the musical \emph{content}.

If you consider the following minimal score and its (complete) LilyPond input file:
\begin{multicols}{2}
\begin{musicExampleNonFloat}
\begin{quote}
\lilypondSFE{examples/minimal-score}
\end{quote}
\end{musicExampleNonFloat}
\columnbreak

\begin{centering}
\begin{lstlisting}
{
  \time 3/4
  \key es \major
  \clef treble
  es'2.
}
\end{lstlisting}
\end{centering}
\end{multicols}

\noindent you can see that the source on the right side completely defines the \emph{musical content} of the score:
a time signature, a key definition, a clef, and a single note with duration.
Of course the page layout is also an inseparable part of the score document, but on a conceptual level it is completely separate from the musical content.
Without going into more detail here you should note that in LilyPond's plain text file you have complete control over the separation of content, meaning and appearance.
While this at first may seem somewhat abstract it is actually a very important point when it comes to preparing different output from one source%
\footnote{See “single-source publishing” section \fref{sec:pt_single-source-publishing}}.

\section{Readability and Stability of Text and Binary Files}
\label{sec:pt_readability-stability}
In the previous section you have seen examples of plain text files for a text and a score document.
OK, I admit that it takes some time getting used to filtering out the markup commands in a text file mentally.
But I can't emphasize enough that you actually \emph{can read} that file \emph{at all}.

Does this bold statement surprise you?
Don't you think that you can immediately conceive the content of the graphical score, much faster and easier than the source file that you first have to read and interpret?
Well, then you are again exchanging the real document file and the graphical representation the graphical programs expose to you.

Please take the time and have a look at \todo{prepare “listings”, put them in appendix and add link to them}.
That's what the file contents from the previous examples actually look like.
After skimming through the Word\texttrademark, OpenOffice\texttrademark, Finale\texttrademark{} and Sibelius\texttrademark{} files you should reconsider the “overly complex” \emph{source code listings} of the previous section.
Now you'll probably see why I emphasize that you can \emph{read} \LaTeX{} and LilyPond files, isn't it?
You may have noticed that both Word\texttrademark{} and OpenOffice\texttrademark{} also have an alternative file format that is stored in “plain \textsc{xml}”.
While a human actually \emph{can} read these files the actual content is very deeply buried inside them and practically inaccessible to the human eye.
	
The fact that plain text files are human readable has two major implications:

\paragraph{Recovery after file corruption}
There are several ways that can make a file unusable, the most common being accidental deletion, a general disk failure or the crash of a program leading to an inconsistent state of the file (the latter fortunately becoming increasingly rare nowadays).
Usually such files can be partially retrieved with special tools, but the picky thing is the “partially”.
If you have a binary file that can only be read by its original program the whole file is now unusable, even if the corrupted portion is very small.
From a corrupted plain text file on the other hand you will be able to retrieve everything \emph{as content} that is still there at all.
And with some luck you may even guess the missing pieces.
Sometimes it will still be more efficient to start again from scratch, but depending on the nature of your project this characteristic of plain text files may actually be a life-saver.

\paragraph{Restoring “ancient” files}
As programs mature they modify their file formats.
Usually programs can still open the files from older program versions, but that isn't an endless option.
With the majority of programs you would need to have some older version to be able to open “ancient” files.
This may actually be a monetary factor---and with some “luck” there doesn't even exist a version that runs on your current operating system.

This may also happen with programs that store their data in plain text files.
But as the file format is usually much better documented it is more likely that you will find a conversion option still available.
And if everything fails and you have a file but no dedicated editor you still have the plain text and free access to it.

\section{Editor Independence}
\label{sec:pt_editor-independence}
Plain text workflows separate the tasks of editing, processing and displaying documents.
This way you are not restricted to \emph{the one} application the (commercial) vendor imposes on you, but you are free to chose any editing environment you like, consider appropriate or just feel comfortable with.
There are programs that try to integrate all parts of a workflow, just like the \textsc{wysiwyg} tools do---but it is your free choice to use them or not.

You can even edit a project with different tools at a time.
For example it might be handy to be able to edit a document with any text editor on your smartphone, or just going to a public internet access point and send yourself an email with a sketch---both of which you would then process to a pdf document when you are home again.

Another interesting application is the use of plain text as input to web forms.
Many web forms, e.\,g.\ in forums, allow you to enter your posts in \emph{Markdown}%
\footnote{\url{http://daringfireball.net/projects/markdown/}},
a minimalist plain text language, and convert them to formatted \textsc{html}.
And by now you can even enter LilyPond code that will be rendered as music examples in Wikipedia entries.

\section{Programmability}
\label{sec:pt_programmability}
Plain text files can be edited not only by any text editor but by \emph{anything} that can edit text files---which makes it accessible to about any programming language you may think of.
You are not restricted to any scripting interface the vendor graciously provides you, but you can apply any imaginable operations with your source files: 
analyze them,
process them,
or even computationally generate them from scratch.

I you have never programmed and don't intend to learn it you may think that's a rather unimportant feature.
But this isn't true at all.
A project you are working with can hire (or have) someone with that ability, so the whole project can benefit enormously from the versatility this offers---without the individual members needing to see any line of programming code.

There are many possible applications, from applying contrapuntal operations or algorithmic composition up to managing music examples in a database.
For example I'm currently working on the infrastructure for a large orchestral score where those who enter the music only work on small segments of the instrumental parts.
The full score (which is initially filled with rests) will automagically build itself and use whatever segments have already been entered.

\section{Compiling Files vs.\ Instant Feedback}
\label{sec:pt_compiling-instant}
One thing the average \textsc{wysiwyg} user needs to get used to is \emph{not} to get instant feedback.
Graphical programs immediately display any updates in their graphical user interface, while the text files first have to be \emph{compiled} before you can see the results of your modification.

While this may seem cumbersome, it actually isn't a problem but an inherent advantage, and a big one!
Other than the graphical program the compiler can first read the input file, get a solid internal representation of the content and structure, and finally take its time to produce the best possible layout for the given content.
It can judge the implication of a modification for the whole document and rethink the layout completely.
The problems graphical programs are encountering are immediately visible when you (for example) try to move a figure in a 250 pages text document with 80 figures, or when you insert some music in the middle of a longer score---tasks that don't upset text based programs at all.

As a logical result from this different approach text based programs (I'm speaking of LilyPond and \LaTeX{} in particular) produce \emph{default output} of significantly superior quality than their graphical counterparts.
While it is obviously possible to produce publication quality output with Finale\texttrademark{} or Sibelius\texttrademark{} (but not with Word\texttrademark{} or OpenOffice\texttrademark) the default output of Lilypond is practically always \emph{readable} and \emph{usable} without any further intervention.
As a rule of thumb I'd say that you can use LilyPond scores (and \LaTeX{} documents) without bothering about layout details as long as you don't want to publish them.
This is a significant improvement for the development process of documents and editions as you can work on the real \emph{content} up to the final stage of print preparation.

Look at the following example of a rather complex score%
\footnote{Arnold Schönberg: Excerpt from: “Nie ward ich, Herrin, müd” | Nr. 4 aus “6 Orchesterlieder" | für Gesang und Orchester | op. 8/1, \copyright{} 1911 by Universal Edition A.\,G., Wien/UE 3041, \href{http://www.universaledition.com/}{www.universaledition.com} [permission granted for use in this tutorial. You may redistribute the document provided you keep this copyright notice in place and don't modify the music contained in this example]}
that LilyPond did \emph{not} manage to engrave perfectly without assistance:

\begin{musicExampleNonFloat}
\lilypondSFE{examples/schoenberg-opus-8-4}
\end{musicExampleNonFloat}

Please note that there is no single manual tweak to that engraving.
I just entered the music and assigned the right voice contexts to it.
Of course this is far from perfect, and the LilyPond developers would surely take this example as a source of inspiration for improvements of the engraving engine.
But if you excuse the long phrasing slur from m.\,1 throughout 3 (which I judge no automated engraving system would be able to get right by itself) you will notice that the engraving is completely readable---you could put it on the music stand and play from it right away (which I can confirm from practical experience \dots).

If you compare that to the attempt one of the two “big players” took at the same measures (with the same prerequisites: entering music, assign voices correctly, no further manual tweaks), you will understand what I mean \dots

\begin{musicExampleNonFloat}
    \musicSFE[trim=2.6cm 21.5cm 1.3cm 2.9cm, clip]{examples/schoenberg-opus-8-4-finale}
\end{musicExampleNonFloat}


\todo{ask UE about permission to also use the “Gethsemane example”. If this is possible place it \emph{before} the two other examples!}

There are a few more features about working with text files that I'll write about in the LilyPond \fref{chap:pt_lilypond}, namely the potentials of using \emph{variables}, of being able to \emph{include} files and design sophisticated cascading set-ups, and finally of \emph{commenting} and \emph{documenting} source files.
But first let's take the time to learn about what is maybe the single most important feature of plain text files: their accessibility to \emph{version control}.

\chapter{Version Control}
\label{chap:pt_version-control}

\emph{Version control} is a concept I had heard of long ago, and I assumed it was one of the tools belonging to software development in general.
But realizing that it can very well be used by musicians and musicologists was a revelation that made me completely revise my working methods last year.
I actually \emph{changed my life} as a document author, and I can't imagine how I could ever have existed without \dots

As a first approximation you may understand version control as an infinitely flexible implementation of \emph{undo/redo} mechanisms.
Versioning stores the complete development history of your document or project and lets you investigate \emph{any} state it has ever been in over time.
Furthermore it lets you roll back (or reapply) \emph{any individual} change you have applied at any time, not necessarily in (reverse) chronological but in arbitrary order.

Suppose two weeks ago you reworked a chapter of your book and now you realize that someone else has just now published exactly the same insights---you need to remove these changes and try to get the chapter into the state it had been before.
With a traditional toolchain you would be lucky to have a version of that state at hand, either as a backup file or printed on paper.
With the backup file you may roll back your work to that state---but of course you lose all work done afterwards.
Or you could put the (digital or printed) backup and the current version side by side and manually emend the changes you applied.
Both solutions are cumbersome, error prone, and they rely on the---random--- existence of a backup of exactly the desired state.

With a document under version control you may identify the exact changeset that you want to undo and just revert these changes -- and leave everything done before or after the way it is.
It may not be obvious to you, but this can easily span decades, programs, and even operating systems' lifecycles---because it works on plain text files as seen in the previous chapter.
You think that's cool? I can tell you it \emph{is}!
And this is just the surface -- we'll later deal with other, maybe even more important aspects of versioning.

\section{Basics of Version Control}
\label{sec:pt_basics-version-control}
The fundament all this is built upon is the line-by-line comparison of the complete project directory that the versioning program performs when you “save” your project%
\footnote{The actual terminology is different but I'll try to speak in familiar terms as long as possible.}.
Of course these “lines” refer to the lines in your plain text files.
In a text document a line will usually contain one coherent entity like a sentence, a list item or the like.
In a score this may be (depending on the complexity of the material) one voice in one measure.
So this means that whenever you save your project the versioning software records (e.\,g.) which sentences or which measures you have modified, stores this as a \emph{changeset}, and adds this to the project history.
And you can completely decide yourself how fine-grained you tailor such changesets:
They may envelope the work of a day, the complete revision of a chapter or a single corrected note.
But note that the first example is actually a bad one because the idea of versioning is to organize the history of a project as a series of coherent sets of changes. 
Probably you'd rather split your day's work into snapshots like 
\begin{inparaenum}[1.)]
\item “proof-reading choir parts” 
\item “adding critical notes”
\item “reorganize directory structure”.
\end{inparaenum}
Note that this concept does work on the project directory and not on single files.
So a changeset can span a whole set of files, thus linking related work together.

\begin{itemize}
\item now in history (forever)
\item can later be accessed individually
\item changed or reverted
\item Each state can be inspected
\item branching
\item repository / working tree, describe as “bag”
\end{itemize}

\section{Collaborative Editing}
\label{sec:pt_collaborative-editing}

\chapter{LilyPond}
\label{chap:pt_lilypond}

\chapter{\LaTeX}
\label{chap:pt_latex}

\chapter{Applications}
\label{chap:pt_applications}

\section{Single-source Publishing}
\label{sec:pt_single-source-publishing}

\end{document}