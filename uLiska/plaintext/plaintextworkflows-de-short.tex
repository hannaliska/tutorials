% This file is part of the openLilyLib project
% Copyright Urs Liska 2013
% This file and the resulting PDF document aren't distributed under a free license.
% You may freely redistribute both the source and the pdf 
% without modifications, however.

\documentclass[DIV=12]{scrreprt}

\usepackage{fontspec}

% Language settings
\usepackage{polyglossia}
\setdefaultlanguage{german}
\frenchspacing

% fontspec base settings
\defaultfontfeatures{%
	Ligatures=TeX
}
\setmainfont[%
	Numbers=OldStyle,
	]{Minion Pro}
\setsansfont[Scale=MatchLowercase,]{Cronos Pro}
\setmonofont[Scale=MatchLowercase]{Inconsolata}

% Typographical improvements
\RequirePackage{microtype}
\RequirePackage[ngerman]{selnolig}

\linespread{1.05}

\RequirePackage{lilyglyphs}

\RequirePackage{xmpFancyref}
\RequirePackage{musicexamples}

\RequirePackage{hologo}

% Do not restart footnote numbering for each chapter
\RequirePackage{chngcntr}
\counterwithout*{footnote}{chapter}

% Enhanced lists
\RequirePackage{mdwlist}
\RequirePackage{paralist}

% Multicolumn texts
\RequirePackage{multicol}

% Extended verbatim (listing) texts
\RequirePackage{fancyvrb}
\usepackage{listings}
\usepackage{OLLstyles}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Options for use of hyperlinks
% (make sure this is included last)
\RequirePackage[%
	colorlinks,
	urlcolor=blue,
	bookmarks=true,
	bookmarksnumbered=true]{hyperref}



\begin{document}
\title{Arbeiten mit Textdateien für Musiker und Musikwissenschaftler}
\author{Urs Liska}
\maketitle

\subsection*{Vorbemerkung}
Die meisten Musiker und Musikwissenschaftler bearbeiten Textdokumente und Partituren oder Notenbeispiele mit grafischen Programmen, ohne eine grundsätzliche Alternative überhaupt in Erwägung zu ziehen.
Der vorliegende Aufsatz zeigt demgegenüber einen Ansatz, der auf der Bearbeitung reiner Textdateien basiert.
Dieser Ansatz ermöglicht neuartige Wege gemeinschaftlichen Arbeitens, Forschens und Publizierens, indem jahrzehntelange Erfahrungen aus der Softwareentwicklung fruchtbar gemacht werden können.
Die beschriebenen Konzepte, Werkzeuge und Workflows haben mein Leben als Autor von Text- und Partiturdokumenten grundlegend verändert, und es ist mir ein großes Anliegen, sie der musikwissenschaftlichen Gemeinschaft zur Diskussion zu stellen.

In den Geisteswissenschaften ist textbasiertes Arbeiten praktisch unbekannt, während es in vielen natur- und computerwissenschaftlichen Disziplinen zum Standard gehört.
Tatsächlich erfordert das Arbeiten mit Textdateien ein grundlegendes Umdenken, und es kann nicht geleugnet werden, dass dies mit einer nennenswerten Lernkurve verbunden ist.
Diese Investition erscheint mir jedoch mehr als gerechtfertigt, da sie auf lange Sicht die Produktivität ebenso erhöht wie die Qualität der Ergebnisse.

Der vorliegende Text ist eine stark verkürzte Fassung des englischen Originals, das unter \url{http://lilypondblog.org/2013/07/plain-text-files-in-music/} erhältlich ist.
Er verzichtet nach Möglichkeit auf ausführliche Erläuterungen (die im Original nachvollziehbar sind) und spitzt die Argumentation deutlicher auf die musikwissenschaftliche Perspektive zu.

Die wesentlichen Softwaresysteme, die ich auf den folgenden Seiten vorstellen -- in deren Benutzung ich aber nicht einführen -- werde, sind:

\begin{itemize*}
\item \emph{Versionsverwaltung} -- behält die Übersicht über Ihre Arbeit
\item \emph{LilyPond} -- das Notensatzprogramm
\item \emph{\LaTeX} -- das professionelle Textsatzsystem
\end{itemize*}

\vfill
\hrule
\medskip
\textcopyright{} Urs Liska 2013 -- Weitergabe des unveränderten Dokuments gestattet.

\tableofcontents

\chapter{Textformate}
\label{chap:pt_plain-text-format}
Im Gegensatz zu \textsc{wysiwig}-Programmen, die eine grafische Ansicht von Dokumenten bieten, ist bei der Bearbeitung von Textdateien das Ergebnis nicht unmittelbar ersichtlich -- der „Quelltext“ muss erst in ein grafisches Dateiformat „übersetzt“ oder „kompiliert“ werden.
Weshalb sollte man sich nun diese Abstraktionsebene aufbürden, wo es doch offensichtlich schnell, einfach und effizient ist, ein Dokument in seinem endgültigen Erscheinungsbild zu bearbeiten?
Ist es nicht nachgerade \emph{natürlich}, eine Partitur grafisch mit einer Maus zu bearbeiten?

Nun, es gibt eine Reihe guter Gründe, Dokumente als Textdateien zu speichern und zu bearbeiten.
Textbasiertes Arbeiten umgeht einige grundlegende Probleme anderer Ansätze, und es eröffnet Perspektiven auf ein breites Spektrum erweiterter Möglichkeiten.
Und schließlich gibt es heutzutage Bearbeitungsprogramme, welche den Umgang mit Textdateien erheblich vereinfachen.

Einleitend werde ich einige grundlegende Aspekte der Verwendung von Reintextformaten erläutern.

\section{Transparenz und Kontrolle}
\label{sec:pt_transparency-and-control}
Grafische Programme (insbesondere solche mit proprietären Dateiformaten) lassen sich hinsichtlich der Speicherung und Interpretation eingegebener Inhalte i.\,d.\,R. nicht in die Karten sehen.
Einer der Hauptgründe, meinem grafischen Notationsprogramm den Rücken zu kehren, war dessen Angewohnheit, scheinbar willkürlich meine manuellen Änderungen zu überschreiben.

Etwas grundsätzlicher formuliert: Bei einem grafischen Programm habe ich keinen Einblick, 
\begin{inparaenum}[1)]
\item in welcher Form ein mit der Maus verschobenes Element gespeichert wird,
\item auf welche Referenz sich die Änderung bezieht und
\item wie das Programm meine Änderung bei einer Layoutanpassung (etwa auf Grund eines neuen Zeilenumbruchs oder Papierformats) behandeln wird.
\end{inparaenum}
Darüber hinaus ist insgesamt nicht ersichtlich, welche Elemente manuell angepasst wurden und welche dem automatischen Ergebnis entsprechen.

In einer Quelltextdatei hingegen ist unzweideutig definiert, welche manuellen Änderungen beabsichtigt sind, diese sind von Jedermann nachzulesen.
Und sollte einmal eine Änderung erhebliche Nebenwirkungen auf das Layout haben, so kann jede einzelne Modifikation gezielt verändert oder zurückgenommen werden -- während ich im grafischen Programm lediglich die Wahl habe, mein Glück mit einer \emph{Undo-}Funktion zu versuchen oder das Problem durch \emph{weitere} Korrekturen in den Griff zu bekommen.

Der Preis dafür ist die Notwendigkeit, den Quellcode händisch einzugeben und dies zunächst zu erlernen.
Doch lohnt sich der Aufwand auf lange Sicht.

\section{Inhalt, Bedeutung und Erscheinungsbild}
\label{sec:pt_separation-content-meaning-appearance}
Die auf Grund der Allgegenwart grafischer Programme verbreitete Vorstellung, das \emph{visuelle Erscheinungsbild} eines Dokuments sei gleichbedeutend mit seinem \emph{Inhalt}, ist ein Trugschluss.
Tatsächlich handelt es sich dabei um zwei verschiedene Ebenen, die nur üblicherweise unter einer Benutzeroberfläche vereint sind.
Ein Text in einer Schriftgröße von 16\,Punkt etwa, der fett und kursiv dargestellt ist, kann auf verschiedenste Weise formatiert sein:
\begin{inparaenum}[1)]
\item als Absatzvorlage,
\item als Zeichenvorlage,
\item als manuelle Formatierung,
\item als Absatz- mit zusätzlicher Zeichenvorlage oder
\item als beliebige Mischung dieser Optionen.
\end{inparaenum}
Je nach Kontext können unterschiedliche Methoden adäquat sein, aus dem Erscheinungsbild einer grafischen Benutzeroberfläche wird jedoch die verwendete Formatierungsart nicht deutlich.

Im Quelldokument eines textbasierten Programms hingegen wird der Text explizit \emph{ausgezeichnet}.
Der Vorteil der strikten und sauberen Trennung zwischen dem Inhalt und dessen Erscheinungsbild überwiegt den Umstand, dass das Erfassen des Inhalts scheinbar schwieriger ist, wenn man bei einem Konstrukt wie „\texttt{Schuberts \textbackslash werktitel\{Winterreise\}}“ den Auszeichnungsbefehl mental ausblenden muss.

Im Falle von Partituren ist die Sache ähnlich gelagert:
Eine textbasierte Partitur-Eingabedatei enthält eine Repräsentation des musikalischen \emph{Inhalts}, während das \emph{Erscheinungsbild} erst während des Übersetzungsvorgangs entsteht und in der resultierenden \textsc{pdf}-Datei zur Verfügung steht.
Diese Kontrolle über die Trennung von Inhalt, Bedeutung und Erscheinung ist eine wichtige Grundlage für die Arbeitstechniken, auf die ich im weiteren Verlauf näher eingehen werde.

\section{Lesbarkeit und Stabilität von Text- und Binärdateien}
\label{sec:pt_readability-stability}
Textdateien sind lesbar, Binärdateien nicht -- diese schlichte Feststellung hat grundlegende Implikationen für den Umgang mit digitalen Dokumenten.

Während die Eingabedatei eines (guten) Reintextformats präzise und lesbar den Inhalt des Dokuments beschreibt, enthält die proprietäre Binärdatei eines kommerziellen Programms einen unverständlichen Datenstrom, der nur von dem entsprechenden Programm oder einem geeigneten Importfilter eines anderen Programms interpretiert werden kann.
Inzwischen bieten zwar viele Programme (so auch \emph{Word} und \emph{OpenOffice}) die Möglichkeit, Dokumente in \textsc{xml}-Formaten abzuspeichern, die ebenfalls zur Gruppe der Textdateien gehören.
Das Verhältnis von tatsächlichem Inhalt und zusätzlichem \emph{Markup} ist dabei jedoch so ungünstig, dass diese praktisch nicht mehr lesbar sind%
\footnote{Im Anhang der englischen Fassung dieses Aufsatzes sind eine Reihe von Rohdateien einfacher Text- und Partiturdokumente abgedruckt, deren Studium an dieser Stelle nachdrücklich empfohlen wird.}.

Die Tatsache, dass Textdateien menschenlesbar sind, hat zwei wesentliche Implikationen:

\paragraph{Datenrettung}
Beschädigte Dateien können heutzutage auch dann \emph{teilweise} wiederhergestellt werden, wenn das Dateisystem zerstört wurde oder die Daten versehentlich gelöscht wurden.
Binärdateien jedoch, die nicht \emph{vollständig} rekonstruiert werden können, sind i.\,d.\,R. komplett verloren, selbst wenn nur ein Bruchteil der Datei beschädigt ist.

Bei der Wiederherstellung korrupter Textdateien hingegen kann praktisch alles, was rekonstruierbar ist, auch wiederverwendet werden, selbst, wenn man nur noch die bloßen Bytes der Datenträgeroberfläche abscannen konnte.
Mit etwas Glück lassen sich die fehlenden Puzzleteile leicht ergänzen.

\paragraph{Verwendung „antiker“ Dateien}
Mit der Weiterentwicklung von Software ändern sich deren Dateiformate.
Auch wenn Programme üblicherweise Dateien ihrer Vorgängerversionen öffnen können, wird deren Unterstützung irgendwann eingestellt, so dass zum Bearbeiten alter Dateien eine ältere Version des Programms erforderlich ist.
Bei einem Wechsel des Betriebssystems verschärft sich dieses Problem erheblich.
Daten werden in aller Regel irgendwann unbenutzbar.

Programme, die mit Textdateien arbeiten, unterliegen dieser Gesetzmäßigkeit ebenso, doch sind diese Dateiformate meist wesentlich besser dokumentiert, so dass die Wahrscheinlichkeit einer verfügbaren Konvertierungsmöglichkeit erheblich größer ist.
Und sollte alles nichts helfen, bleibt zumindest noch die „rohe“, menschenlesbare und frei zugängliche Datei, für die prinzipiell jederzeit ein neues Bearbeitungs- oder Konvertierungsprogramm geschrieben werden kann.

Textdatei-basierte Projekte können auf diese Weise -- insbesondere in Verbindung mit Versionskontrolle (siehe das nächste Kapitel) -- ungeahnte Zeiträume einer Vielzahl von Computergenerationen umspannen.
Dies macht diese Herangehensweise besonders geeignet für akademische Zwecke.

\section{Editor-Unabhängigkeit}
\label{sec:pt_editor-independence}
Textbasierte Arbeitsumgebungen trennen das Bearbeiten, Verarbeiten und Anzeigen von Dokumenten.
Auf diese Weise ist man nicht an \emph{die eine} Anwendung gebunden, die vom (kommerziellen) Hersteller vorgegeben ist, sondern kann je nach Kontext beliebige Bearbeitungsprogramme verwenden.
Beispielsweise kann an einem Projekt gleichzeitig mit verschiedenen Werkzeugen gearbeitet werden, so können Skizzen ohne Weiteres auf dem Smartphone oder in einem Internetcafé notiert und später mit den Hauptdokumenten verbunden werden.
Ebenso ist das Textformat ein geeignetes Mittel, um Dokumente in einem Internetbrowser notieren zu können.
So gibt es inzwischen eine Reihe von Projekten, die aus Texteingabe im Browser Notation erzeugen können, am prominentesten die neue Wikipedia-Erweiterung%
\footnote{\url{http://en.wikipedia.org/wiki/Help:Score}}.

\section{Programmierbarkeit}
\label{sec:pt_programmability}
Textdateien können nicht nur mit jedem Texteditor, sondern auch mit jeder Programmiersprache bearbeitet werden.
Die meisten Anwendungsprogramme bieten heute Schnittstellen für Skriptsprachen, mit deren Hilfe zusätzliche Funktionalität ergänzt werden kann.
Im Gegensatz zu diesen, vom Hersteller explizit vorgegebenen, Möglichkeiten können Textdateien jedoch in jeder nur erdenklichen Weise programmatisch bearbeitet werden: Man kann den Inhalt analysieren oder verändern, oder sie auch gänzlich neu generieren.
Die Liste möglicher Anwendungen ist lang und reicht (bei Partituren) von kontrapunktischen Operationen über algorithmische Komposition bis hin zur Verwaltung umfangreicher Beispielsammlungen in einer Datenbank (mit Internetzugriff).

Von dieser Option können auch Nutzer profitieren, die selbst nie programmiert haben und es auch nicht lernen wollen.
So kann in größeren Projekten mit Hilfe von Programmierung eine Infrastruktur geschaffen werden, welche die Komplexität vor dem Einzelnen gerade \emph{verbirgt}.

\section{Unmittelbares Feedback vs. Übersetzung}
\label{sec:pt_compiling-instant}
Einer der Aspekte textbasierten Arbeitens, an den sich Benutzer am meisten gewöhnen müssen, ist das Fehlen eines unmittelbaren visuellen Feedbacks eingegebener Änderungen.
Grafische Programme reflektieren jegliche Änderung sofort, während die Eingabedatei des textbasierten Programms zunächst kompiliert werden muss.

Obwohl dies zunächst umständlich erscheint, ist es ein inhärenter bedeutender Vorteil.
Während der Arbeit im Dokumenteninhalt kann und \emph{muss} der Autor sich nicht mit Fragen des Layouts befassen, und das Programm muss nicht jede minimale Änderung sofort mit einem brauchbaren Ergebnis quittieren (was etwa bei einem größeren Textdokument mit vielen eingebetteten Abbildungen durchaus eine große Herausforderung ist und die Flüssigkeit des Arbeitens einschränken kann).
Dafür kann sich das Programm beim eigentlichen Übersetzungsvorgang genügend Zeit nehmen, um zunächst eine interne Repräsentation der \emph{Struktur} zu erzeugen und schließlich das Layout bestmöglich zu erstellen.

Die Konsequenz hieraus ist eine Standard-Ausgabe von erheblich höherer Qualität als bei grafischen Programmen%
\footnote{Für einige Beispiele siehe die englische Fassung des Aufsatzes}.
Als Faustregel kann man bei textbasierten Programmen (wie LilyPond und \LaTeX) davon ausgehen, sich erst dann mit Formatierungsdetails befassen zu müssen, wenn tatsächlich eine Veröffentlichung vorbereitet werden muss.
Dies ist auf lange Sicht ein erheblicher Vorteil, da man sich als Autor bis zur eigentlichen Druckvorbereitung auf den eigentlichen \emph{Inhalt} des Dokuments konzentrieren kann.

\bigskip
\hrule
\bigskip

Einige weitere Vorzüge der Arbeit mit Textdateien, insbesondere die Verwendung von \emph{Variablen}, kaskadierenden Set-ups durch \emph{Inklusion} von Dateien sowie die \emph{Kommentierung} und \emph{Dokumentation} von Quelldateien, werde ich im Kapitel \ref{chap:pt_lilypond} über LilyPond (ab S.\,\pageref{chap:pt_lilypond}) vorstellen.
Doch zunächst werde ich auf den vielleicht wichtigsten Aspekt textbasierten Arbeitens eingehen: \emph{Versionskontrolle}.

\chapter{Versionskontrolle}
\label{chap:pt_version-control}
Das Konzept der \emph{Versionskontrolle}%
\footnote{\url{http://de.wikipedia.org/wiki/Versionsverwaltung}}
ist vor allem aus der Softwareentwicklung bekannt, wo es bei Projekten ab einer gewissen Größe zum Standardrepertoire gehört.
Zu realisieren, dass es ebensogut für musikalische wie musikwissenschaftliche Zwecke nutzbar gemacht werden kann, war eine Erkenntnis, die meine Arbeitsmethoden grundlegend verändert hat.

In einer ersten Näherung kann man Versionskontrolle als eine unendlich flexible Ausprägung des \emph{Rückgängig/Wiederherstellen}-Mechanismus begreifen.
Versionierung dokumentiert die gesamte Entstehungsgeschichte eines Dokuments bzw. eines Verzeichnisses von Dokumenten und erlaubt es, \emph{jeden beliebigen} vergangenen Zustand des Projekts zu inspizieren oder wiederherzustellen.
Darüber hinaus erlaubt sie, jeden einzelnen Änderungsschritt individuell, d.\,h. nicht notwendig in chronologischer Reihenfolge zu widerrufen.
So kann etwa die Überarbeitung eines bestimmten Kapitels, die vor zwei Wochen durchgeführt wurde, rückgängig gemacht werden, ohne die sonstige seitherige Arbeit zu berühren.
Traditionellerweise wäre man auf das Vorhandensein eines Backups genau des gewünschten Zustands angewiesen und würde bei der Gelegenheit alle spätere Arbeit verlieren.

Es mag nicht selbsterklärend sein, aber dies kann ohne Weiteres Jahrzehnte, Programmwechsel und sogar Betriebssystemgenerationen überdauern -- weil Textdateien gewissermaßen zeitlos sind, wie im vorigen Kapitel erläutert wurde.
Die ältesten bekannten Software-Projekte, die heute noch entwickelt werden, haben eine kontinuierliche Versions-History seit den 80er Jahren des vergangenen Jahrhunderts.
Dies ist auch eine hervorragende Perspektive für (musikalische oder andere) Gesamtausgaben und vergleichbar langfristig angelegte akademische Projekte.

\section{Grundlagen der Versionskontrolle}
\label{sec:pt_basics-version-control}
Das Fundament der Versionskontrolle ist der zeilenweise%
\footnote{„Zeilenweise“ bezieht sich auf die Zeilen der Quelltextdatei.}
Vergleich eines gesamten Projektverzeichnisses.
Quelldatei-Zeilen beinhalten üblicherweise eine logische Einheit wie etwa einen Satz (in einem Textdokument) oder einen Takt einer Stimme in einer Partitur.
In einem sogenannten „Commit“ wird ein Satz zusammenhängender Zeilen-Änderungen in 
einem Projektverzeichnis zusammengefasst, es wird also eine Liste aller geänderten (z.\,B.) Sätze während eines Bearbeitungsschrittes dokumentiert.
Der Zuschnitt dieser Liste ist dabei frei wählbar:
Ein Commit kann die Korrektur eines Rechtschreibfehlers bzw. eines Taktstriches umfassen oder die Überarbeitung eines kompletten Kapitels.
Diese Menge von Änderungen wird -- mit einer erläuternden Beschreibung versehen -- der Projektgeschichte hinzugefügt und kann später zu jedem Zeitpunkt eingesehen, widerrufen oder verändert werden.

In diesem mächtigen zeilenweisen Ansatz liegt auch der Grund für die ausschließliche Anwendbarkeit von Versionskontrolle auf textbasierte Dateiformate.
In Binärdateien lassen sich Änderungen überhaupt nicht erfassen, und auch \textsc{xml}-basierte Formate eignen sich nur sehr bedingt für die Versionierung:
Allein durch das Öffnen und Speichern eines Dokuments (ohne tatsächliche Änderungen) werden so viele Zeilen der Datei verändert (etwa durch Angaben über Zeitstempel oder geöffnete Werkzeugleisten), dass der resultierende Commit praktisch nichtssagend wird.

Ein wichtiges und mächtiges Konzept der Versionskontrolle sind \emph{Zweige} (\emph{branches}).
Diese kann man etwa wie eine unabhängige „Sitzung“ verstehen, in deren Kontext man arbeitet, ohne die übrigen Sitzungen zu beeinflussen.
Ein üblicher und leicht verständlicher Verwendungszweck von Zweigen ist es, 
Arbeitsschritte abzugrenzen, die das Projekt zeitweise in einen inkonsistenten Zustand bringen.
So würde man beispielsweise die kritische Revision einer Notenausgabe im Rahmen eines Zweiges erledigen, wodurch die Partitur zu keinem Zeitpunkt eine Mischform zwischen Hauptquelle und revidierter Form aufweist.
Später lässt sich der Überarbeitungsvorgang dann jederzeit detailliert nachvollziehen.

\section{Gemeinschaftliches Arbeiten}
\label{sec:pt_collaborative-editing}

Der bedeutendste Aspekt jedoch, der akademischem Arbeiten wirklich neue Impulse verleihen kann, ist das von Versionskontrolle erheblich profitierende \emph{gemeinschaftliche Arbeiten%
\footnote{Der englische Begriff \emph{collaboration} erscheint mir dabei treffender.}}.
Dabei ist „Arbeiten“ in doppeltem Sinne gemeint: als Erarbeiten eines (Forschungs-)Gegenstands und als Bearbeiten von Dateien.
Versionskontrolle reduziert in erheblichem Maße Schwierigkeiten, die üblicherweise bei der gemeinsamen Bearbeitung von Dokumenten entstehen.

Die heute bei weitem verbreitetste Methode gemeinsamen Arbeitens besteht im Austausch von Dateien per Email, Datenträger oder der abwechselnden Bearbeitung im Netzwerk (oder der „Cloud“) lagernder Dateien.
Abhängig von der jeweiligen Einrichtung sind dabei mehr oder weniger umständliche Vorkehrungen erforderlich, um inkonsistente Datenzustände zu vermeiden.
Durch Austausch entstehende Kopien von Dokumenten müssen verwaltet werden, es muss dafür gesorgt werden, dass nicht zwei Personen gleichzeitig verschiedene Versionen des Dokuments verändern%
\footnote{Dies kann etwa geschehen, wenn ich ein vom Partner bearbeitetes Dokument zurückerhalte und weiterbearbeite, der Partner dann jedoch weitere Änderungen „nachreicht“},
und schließlich behindert das -- technisch oder durch Vereinbarung bedingte -- „Sperren“ von Dokumenten das freie Arbeiten.
Und schließlich wird eine derart gestaltete Zusammenarbeit vollends unpraktikabel, wenn dabei eine große Zahl von Dokumenten von mehr als zwei Mitarbeitern benutzt werden soll.

Hier nun setzt Versionskontrolle an.
Die Verwendung von Textdateien in Verbindung mit Versionskontrolle ermöglicht es, von jahrzentelanger Erfahrung in der Softwareentwicklung zu profitieren.
Deren Techniken und Strategien wurden insbesondere entwickelt, um die reibungslose Zusammenarbeit zahlreicher Mitarbeiter zu gewährleisten%
\footnote{So zählt beispielsweise das Linux Kernel Projekt mehrere Hunderttausend Commits von über zehntausend Beitragenden (es gibt leider keine adäquate Übersetzung für das passendere \emph{contributor}).}.

Der Kern einer gemeinschaftlichen Arbeitsumgebung ist eine gemeinsame Datenbasis, ein auf einem Server gespeichertes \emph{repository}, das allen Mitarbeitern zugänglich ist (wobei auch gestaffelte Rechte vergeben werden können).
Jeder Mitwirkende verfügt über eine lokale Kopie des Datenbestands, in der er uneingeschränkt arbeiten kann, auch ohne permanent mit dem Server verbunden zu sein.
Bei Gelegenheit gleicht er den lokalen und den zentralen Datenbestand miteinander ab, kann gezielt Beiträge anderer Mitarbeiter inspizieren und schließlich seine eigene Arbeit in den gemeinsamen Datenbestand integrieren.

Die beschriebene zeilenweise Vorgehensweise der Versionsverwaltung spielt nun ihre Vorteile bei verteiltem Arbeiten vollends aus, indem sie jegliches Sperren von Dateien überflüssig macht.
Und es kann nicht genug betont werden, dass das \emph{gleichzeitige} Bearbeiten von Dateien grundsätzlich kein Problem darstellt:
So könnte beispielsweise ein Herausgeber Fingersätze bearbeiten, während ein anderer die kritische Revision durchführt.
Solange die beiden nicht \emph{dieselbe Quelltextzeile} verändern, wird die Versionskontrolle alles transparent und unbemerkt integrieren.
Dies zielt nicht darauf ab, Konflikte \emph{unwahrscheinlich} zu machen -- das wäre fahrlässig.
Sollte das System Dateiversionen nicht selbständig zusammenführen können, wird der Bearbeiter auf die divergierenden Zeilen hingewiesen und kann den Konflikt manuell auflösen.
Versionierung kann und wird also Bearbeitungskonflikte nicht verhindern, garantiert jedoch, dass sie mit minimalem Aufwand behoben werden können, und zwar ziemlich unabhängig von der Anzahl der Mitarbeiter und betroffenen Dateien.

\medskip
Ein weiterer wichtiger Aspekt ist die Art und Weise, wie Änderungen am Datenbestand dokumentiert werden.
Wie beschrieben speichert ein \emph{commit} einen Satz an Änderungen, der später eingesehen werden kann.
Möchte ich also Änderungen beurteilen, die ein Partner eingebracht hat, so werden mir diese direkt angezeigt, ohne dass ich in den Dokumenten nach ihnen suchen müsste.
Im Gegensatz zu entsprechenden Funktionen, die zum Beispiel Textverarbeitungen bieten, ist diese Dokumentation permanent und verschwindet nicht, nachdem die Änderungen akzeptiert oder verworfen wurden.
Und bei Partituren wüsste ich nicht, wie ich außer mit einem -- fehleranfälligen -- AB-Vergleich den Korrekturdurchgang eines Anderen in einem grafischen Notationsprogramm überhaupt überprüfen könnte.


\medskip
Zusammenfassend kann man sagen, dass in einem Projekt unter Versionskontrolle eine beliebige Anzahl von Mitarbeitern auf einen beliebig großen gemeinsamen Datenbestand zugreifen kann.
Versionskontrolle garantiert die Minimierung von Zusammenführungskonflikten, bietet einfache Mittel, diese im Fall des Falles aufzulösen und verwaltet die Projekt-History sauber und transparent, notfalls auch über Jahrzehnte.
Dies eröffnet vielversprechende Perspektiven für akademische Projekte und Arbeitsweisen, von denen ich im abschließenden Kapitel ab S.\,\pageref{chap:pt_applications} einige näher vorstellen werde.
Doch zunächst werde ich auf die zwei hauptsächlichen Softwareprogramme eingehen, die ich für musikwissenschaftliches Arbeiten empfehlen möchte:
Das Notensatzprogramm LilyPond und
das Textsatzsystem \LaTeX.

\chapter{LilyPond}
\label{chap:pt_lilypond}
Mein persönlicher Favorit für Notensatz jeglicher Art ist das freie Programm \emph{GNU LilyPond}%
\footnote{\url{http://www.lilypond.org}}.
Neben dem hervorragenden Notenbild im Allgemeinen -- das jeglichen verlegerischen Qualitätsanspruch zu erfüllen vermag -- möchte ich einige weitere Vorteile hervorheben, die insbesondere für die vorgeschlagene Verwendung im akademischen Bereich relevant sind:

\begin{itemize*}
\item die saubere Trennung von musikalischer Struktur und notentypografischen Anpassungen,
\item die Qualität der unbearbeiteten Standard-Ausgabe, die eine Konzentration auf den \emph{Inhalt} fördert,
\item die hervorragende Integrierbarkeit in Textdokumente,
\item die Möglichkeit der Versionierung sowie
\item weitere aus dem textbasierten Zugang resultierende Aspekte, die im Folgenden näher ausgeführt werden.
\end{itemize*}

Da LilyPond Partituren setzt, indem es \emph{Eingabedateien} übersetzt, die nach bestimmten Syntax-Vorgaben geschrieben werden müssen, ist es tatsächlich erforderlich, die Eingabesprache zu erlernen.
Eine Einführung in diese kann natürlich nicht Gegenstand des vorliegenden Überblicks sein.
Um eine konkrete Vorstellung von LilyPonds Texteingabe zu erhalten, empfehle ich den Einführungsaufsatz auf der Webseite%
\footnote{\url{http://www.lilypond.org/introduction.html}}, und in der englischen Fassung meines Texts finden sich ebenfalls einige Seiten hierzu.

\bigskip
Glücklicherweise ist man heutzutage nicht mehr darauf angewiesen, den Quelltext auf sich allein gestellt in einem simplen Texteditor zu verfassen.
Es existieren eine Reihe von Programmen für verschiedenste Betriebssysteme, die den Autor in vielfältiger Weise unterstützen.
Als Beispiel sei \textit{Frescobaldi%
\footnote{\url{http://www.frescobaldi.org}}}
genannt, das derzeit vermutlich umfangreichste Programm zur komfortablen Bearbeitung von LilyPond-Partituren.
Wie in Abb.\,\ref{fig:pt_fb-main-window} mit einer kleinen Partitur zu sehen ist, bietet das Programm neben einer Partituransicht einen Quelltexteditor, zahlreiche Werkzeugleisten und -- nicht zu sehen -- weitere Assistenten und hilfreiche Details.
	\begin{figure}
	\includegraphics[max width=\textwidth]{examples/frescobaldi/main-window}
	\caption{Hauptfenster von Frescobaldi, mit Partituranzeige, Quelltext-Editor und Werkzeugleisten}
	\label{fig:pt_fb-main-window}
	\end{figure}
Der Editor vereinfacht die Arbeit durch farbige Auszeichnung der Struktur (\emph{syntax highlighting}) und bietet Features wie die automatische Vervollständigung von Befehlen oder der Navigation im Quelltext.
Besonders wichtig ist jedoch die automatische Verknüpfung zwischen Quelltext und Partitur, die es ermöglicht, in der Partitur ein Element anzuklicken, wodurch die Einfügemarke automatisch an die entsprechende Stelle im Quelltext gebracht wird.
Daher ist es inzwischen nicht mehr problematisch, in komplexen Dateien die Übersicht zu behalten.

Ein Fokus der Entwicklung von Frescobaldi liegt derzeit darin, der Partiturdarstellung größere Funktionalität zu vermitteln.
So wird beispielsweise daran gearbeitet, Tonhöhen direkt in der Partitur  korrigieren oder Bögen und ähnliche Elemente grafisch anpassen zu können.
Die Tendenz geht allgemein dahin, die Arbeit mit Partituren komfortabler zu gestalten und dabei die Vorzüge des textbasierten Ansatzes nicht zu verlieren.

\section{Variablen und Inklusion}
\label{sec:pt_variables-includes}
In einer LilyPond-Eingabedatei wird die Struktur der Partitur (natürlich) textlich definiert.
Ein grundlegender \cmd{score}-Block sieht etwa folgendermaßen aus:

\begin{quote}
\begin{minipage}{\textwidth}
\begin{verbatim}
\score {
  \new Staff { ... Musik ... }
  ...
}
\end{verbatim}
\end{minipage}
\end{quote}

Anstatt nun den musikalischen Inhalt direkt in die Definition des Notensystems einzufügen, wird man diesen in aller Regel in einer \emph{Variablen} notieren und im Notensystem lediglich darauf \emph{verweisen}.
Dies mag auf den ersten Blick wie ein syntaktisches Detail wirken, hat aber ganz erhebliche Auswirkungen auf die Arbeit mit dem Material:
Habe ich weiter oben über die Unterscheidung von \emph{Inhalt} und \emph{Erscheinungsbild} gesprochen, so geht es hier um die Unterscheidung von \emph{Definition} und (Wieder-)\emph{Verwendung} des musikalischen Inhalts.
Musik, die in einer Variablen definiert ist, wird in einer Partitur verwendet.
Und sie kann ebenso in einer anderen Partitur verwendet werden.
Durch diese grundsätzliche Herangehensweise kann eine anders kaum mögliche Stabilität beim Herstellen von Einzelstimmen oder Transposition erreicht werden.
Einmal definiertes Material kann beliebig wiederverwendet werden.

\bigskip
Eine erhebliche Erweiterung ihres Potenzials erhalten Variablen durch die Möglichkeit, in separate Dateien ausgelagert zu werden, die durch einen \cmd{include}-Befehl in das zentrale Partiturdokument integriert werden.
Nicht nur Musik, auch Formatierungsbefehle oder manuelle Layoutanpassungen können auf diese Weise \emph{wiederverwendet} werden, und es können -- ähnlich den bekannten \emph{Cascading Style Sheets (\textsc{css})} im Webdesign -- komplexe und mächtige Szenarien entwickelt werden.
So können etwa Stildefinitionen hierarchisch auf globaler, Haus-, Projekt- und Dateiebene verwaltet werden -- Änderungen etwa der Projekt-Stilvorlage wirken sich dann automatisch auf alle Partituren des Projekts aus.
Ebenso kann etwa durch den Austausch einer einzigen \cmd{include}-Anweisung zwischen Layouteinstellungen für Partitur, Einzelstimme, Studienpartitur oder Projektor gewechselt werden.
Denkbar und nützlich ist beispielsweise auch ein Entwurfsmodus, bei dem während der Entwicklung der Partitur Herausgeberzusätze farblich hervorgehoben werden und der Zeilen- und Seitenumbruch der Originalvorlage übernommen wird.
Darüber hinaus können hauseigene oder projektbezogene Funktionsbibliotheken erstellt und gepflegt werden.

\section{Kommentare}
\label{sec:pt_lilypond-comments}
Wie bei jedem Texteingabeformat können auch in LilyPond-Dateien \emph{Kommentare} in den Quelltext eingefügt werden, die bei der Übersetzung ignoriert werden.
Diese dienen zunächst der Dokumentation und Erläuterung des Quelltextes, können aber auch zur Kommentierung und Diskussion des Inhalts verwendet werden und beispielsweise offene Fragen festhalten.

Derzeit wird an einer erheblichen Ausweitung dieses Konzepts mit Blick auf kritische Ausgaben gearbeitet.
In Kürze wird es möglich sein, explizite Kommentare in den Quelltext -- \emph{d.\,h. in unmittelbarer Nähe der Definition des Notentexts} -- einzufügen und von einem Hilfsprogramm zu verschiedenartigen Listen aufbereiten zu lassen.
Auf diese Weise können unmittelbar aus dem Partiturdokument heraus Listen mit \textsc{todo}s, editorischen und typografischen Fragen und schließlich auch kritischen Anmerkungen erzeugt werden.
Von den Listeneinträgen führen Links direkt an die entsprechende Stelle im Quelltext.
Geplant ist darüber hinaus, die Kommentare direkt in Frescobaldis Partituransicht bearbeiten zu können -- somit wird es möglich, die gesamte Vorbereitung einer kritischen Ausgabe \emph{innerhalb der konkreten Partitur} durchführen zu können!
Die Krönung wird schließlich die Möglichkeit sein, die in der Partitur gespeicherten Einträge zum kritischen Bericht direkt in eine schriftliche Fassung exportieren zu lassen.

\section{Programmierbarkeit}
\label{sec:pt_lilypond-programmability}
Weiter oben auf S.\,\pageref{sec:pt_programmability} habe ich über den programmatischen Zugriff auf Textdateien gesprochen.
Dies trifft selbstverständlich auch auf LilyPond-Dateien zu, wobei auf zwei Ebenen programmiert werden kann:
Einerseits verfügt LilyPond mit Scheme%
\footnote{\url{http://de.wikipedia.org/wiki/Scheme}}
über eine mächtige und praktisch unbeschränkte Erweiterungssprache, mit der die Funktionalität des Programms fundamental erweitert werden kann (ein Großteil der eingebauten Funktionalität basiert auf Scheme)%
\footnote{So zeigt etwa Nicolas Sceaux in einer Reihe von Blog-Beiträgen, wie LilyPonds Notation um historische Ornamente erweitert werden kann, die dann als Befehle genauso wie die eingebauten zur Verfügung stehen: \url{http://lilypondblog.org/2013/08/adding-ornamentations-to-note-heads-part-1/}}.
Andererseits können die Eingabedateien selbst mit beliebigen Programmiersprachen bearbeitet oder generiert werden.

Für den normalen Umgang mit LilyPond sind selbstverständlich keine Programmierkenntnisse erforderlich, jedoch öffnet die Programmierbarkeit Perspektiven für größere Projekte.
Und in solchen kann die komplexe Programmierung von wenigen Spezialisten übernommen werden, um der Mehrzahl der normalen Mitarbeiter eine einfachere Arbeitsumgebung zu bieten.
Derzeit arbeite ich zum Beispiel an der Edition eines großen Orchesterwerks%
\footnote{Oskar Fried: \emph{Das trunkne Lied}, siehe \url{http://lilypondblog.org/2013/06/das-trunkne-lied/}}.
Dieses Projekt is so eingerichtet, dass der einzelne Bearbeiter jeweils nur mit einem kurzen Segment (d.\,h. dem Inhalt einer Stimme im Umfang einer Probenziffer) konfrontiert ist.
Die Partitur und die Einzelstimmen können zu jedem Zeitpunkt erzeugt werden und verwenden in einer von Pausen erfüllten Partitur alle bereits eingegebenen Segmente.
Die Arbeit kann so einerseits beliebig „parallelisiert“ werden und andererseits von Personen erledigt werden, die möglicherweise mit der Bearbeitung einer ganzen Partitur überfordert wären.

\bigskip
\hrule
\bigskip

Durch die in diesem Kapitel beschriebenen Eigenschaften bietet sich LilyPond in hervorragender Weise für die musikwissenschaftliche Editionspraxis an.
Dabei wurden die Integrationsmöglichkeiten mit Textsatz durch \LaTeX{} noch nicht einmal näher erläutert und das Potenzial der Versionskontrolle nicht erneut hervorgehoben.

Es gibt allerdings derzeit einen Schönheitsfehler, der an dieser Stelle nicht unterschlagen werden kann: den Datenaustausch mit anderen Programmen.
Momentan ist die Verwendung von LilyPond noch eine Einbahnstraße, deren einziger Ausgang die verschiedenen grafischen Partiturformate sind.
Leider ist es nicht möglich, eine in LilyPond eingegebene Partitur in Formate zu exportieren, die von anderen Notationsprogrammen gelesen werden können.
Dies ist insofern ein großes Problem (abgesehen davon, dass unkooperatives Verhalten ohnehin problematisch ist), als die Mehrzahl der Verlage auf Dateien der beiden großen grafischen Programme besteht und LilyPond-Dateien nicht akzeptiert.

Die Vorbereitung von Notenausgaben mit LilyPond wäre auch äußerst sinnvoll, wenn die endgültige Druckvorbereitung mit \emph{Fin}ale oder \emph{Sibelius} durchgeführt würde.
Daher ist die Ergänzung einer Exportmöglichkeit in das gebräuchliche Austauschformat MusicXML eines der wichtigsten Desiderata aus musikwissenschaftlicher Perspektive.
Diese scheint kein grundsätzliches technisches Problem, sondern „nur“ eine Frage der Ressourcen zu sein -- für eine grundlegende Implementierung wären wohl lediglich einige Wochen Arbeit eines einzelnen Programmiers erforderlich.
\emph{Ein} größeres Projekt wäre möglicherweise genug, um sowohl den MusicXML-Export als auch die zuvor beschriebene Erweiterung der Quelltextkommentierung zufriedenstellend zu realisieren \dots


\chapter{\LaTeX}
\label{chap:pt_latex}

\LaTeX{} ist für Textdokumente, was LilyPond für Partituren ist:
es bietet Text\emph{satz}, im Gegensatz zu bloßer Text\emph{verarbeitung}.
Wem an guter Typografie gelegen ist, wird \LaTeX{} lieben, wer ihr aber keine Bedeutung beimisst, sollte bedenken, dass „keine Typografie“ nicht möglich ist -- sie wirkt \emph{immer}. 

Mit Textverarbeitungsprogrammen wie Word oder OpenOffice ist es unmöglich, professionell gesetzte Dokumente zu erstellen, insofern ist \LaTeX{} eher in Konkurrenz zu \textsc{dtp}-Programmen wie InDesign QuarkXPress zu sehen.
Hinsichtlich der Qualität zumindest bei Textdokumenten muss man bei der freien Software keine Abstriche machen.
Da \LaTeX{} ursprünglich für den Buchsatz entwickelt und seit Jahrzehnten verbessert wurde, bietet es selbstverständlich weitestgehende Möglichkeiten für Literaturverwaltung, Zitate, Indizes etc.
Darüber hinaus bietet \LaTeX{} alle Vorzüge, die ich für textbasierte Softwaresysteme im Allgemeinen  beschrieben habe.

Die Schnittstelle zu \LaTeX{} ist ähnlich wie bei LilyPond:
Eingabedateien mit einer ähnlichen Syntax werden in \textsc{pdf}-Dateien \emph{übersetzt}.
Auf Grund des Alters des Systems existieren zahllose Bearbeitungsprogramme unterschiedlichen Zuschnitts und Komforts.
Die Eingabesprache bietet \emph{Befehle} und \emph{Umgebungen}, die entfernt mit Text- und Absatzvorlagen von Textverarbeitungsprogrammen vergleichbar, jedoch ungleich mächtiger sind:
Sie reichen von einfacher semantischer Auszeichnung über (etwa) Abbildungen, die nach traditionellen Satzregeln im Text positioniert werden bis hin zu komplexen Befehlen mit mehreren Argumenten.

Eine noch so oberflächliche Einführung in \LaTeX{} würde den Rahmen dieses Textes sprengen, daher beschränke ich mich auf einige Hinweise zu spezifisch musikalischen Aspekten.


\section{Musikbeispiele}
\label{sec:pt_music-examples}

\LaTeX{} ist in der Lage, Abbildungen satztechnisch hochwertig einzufügen und hat auch keine Schwierigkeiten mit einer Vielzahl von Bildern in langen Dokumenten.
Zur Verwaltung von Notenbeispielen gibt es jedoch einige speziellere Werkzeuge, insbesondere \package{lilypond-book} and \package{musicexamples}.

\package{lilypond-book} ist ein Hilfsprogramm, das gemeinsam mit LilyPond ausgeliefert wird und ermöglicht, LilyPond-Code direkt in \LaTeX-Dokumente einzufügen.
Beim Durchlauf werden die Notenbeispiele bei Bedarf neu erzeugt und der Quellcode durch entsprechende Bilddateien ersetzt.
Der potenzielle Nachteil an diesem Ansatz ist, dass die zu bearbeitende Datei nicht direkt von \LaTeX{} übersetzt werden kann, sondern zunächst \package{lilypond-book} durchlaufen muss.
Für Dokumente mit vielen kurzen Notenbeispielen kann es jedoch die effektivste Möglichkeit sein, die Noten \emph{in situ} zu verwalten.

Demgegenüber versteht sich \package{musicexamples}%
\footnote{\url{http://www.openlilylib.org/musicexamples}} 
als ein Werkzeug, das sich mehr der Einbettung und konsistenten Verwaltung von Notenbeispielen widmet.
Besonderes Augenmerk wurde auf den Umgang mit ganz- und mehrseitigen Notenbeispielen gelegt, für eine weitergehende Integration speziell von LilyPond-Partituren existieren konkrete Pläne.
Insbesondere ist mittelfristig vorgesehen, mit Hilfe der in \hologo{LuaLaTeX} verwendeten Programmiersprache \emph{Lua} ebenfalls die Einbettung von LilyPond-Quellcode zu ermöglichen -- allerdings dann ohne den Umweg über ein zwischengeschaltetes Hilfsdokument.

\section{Notationselemente}
\label{sec:pt_notational-elements}
Mit Hilfe des Pakets \lilyglyphs%
\footnote{\url{http://www.openlilylib.org/lilyglyphs}}
ist es möglich, \emph{jegliche} mit LilyPond realisierbare Notationselemente auf Zeichenebene in \LaTeX-Dokumente einzubetten.
Dies können etwa dynamische Zeichen wie \lilyDynamics{mf}, Vorzeichen wie \flatflat{} oder auch grafische Zeichen wie \crescHairpin{} oder Taktbezeichnungen (\lilyTimeSignature{4+3}{8} oder \lilyTimeCHalf) sein.
Mit etwas größerem Aufwand kann man auch individuelle Notationen erstellen und einbinden.
Das Schöne daran ist, dass man mit dem Paket den \emph{gesamten} Notationsvorrat von LilyPond in dessen hervorragender Qualität zur Verfügung hat und die verwendeten Zeichen als Zeichen problemlos im Text fließen und sich leicht in Größe und Positionierung anpassen lassen.

\bigskip
Ideen für weitere Pakete, die bei konkretem Bedarf jederzeit in Angriff genommen werden können, umfassen beispielsweise funktionsharmonische Analysesymbole oder Generalbassbezifferungen.

\chapter{Applications}
\label{chap:pt_applications}

\section{Preparing a Musical Edition}
\label{sec:pt_preparing-edition}
This is what I actually experienced recently---and what I definitely don't want to miss anymore.
During the preparation of an edition I'm currently working on we switched our workflow from sharing files in a Dropbox%
\footnote{Dropbox is a cloud based file hosting provider. See \url{http://www.dropbox.com}}
to versioning it with Git.
It was a real revelation to me, and I don't know how we managed before.
This becomes especially obvious when we are dealing with issues that date from before that time and there isn't any Git history present to inspect them.

There are several steps in preparing a scholarly edition, which are partly interdependent and are partly distributed between different team members:
\begin{itemize*}
    \item Entering the music
    \item Setting up the score layout and the style sheets
    \item Proof-reading the music
    \item Scholarly revision
    \item Fine-tuning the engraving
    \item Authoring critical reports
    \item Layout of the main volume and prepress
\end{itemize*}

First of all the complete process can be done within one code base.
Any collaborator can edit anything at any time, usually without stepping on others' feet, as described in the “Versioning” \fref{chap:pt_version-control}.
Traditionally one would work with one file (or one for each piece/movement) and would have to take great care about potential version conflicts.
Basically these files would have to be completely processed by one person before being passed on to the next in the chain.

An important side-effect of this situation is that tasks can be shared in a much more flexible way.
As anybody can edit everything he can also handle any task he feels able or has time to.
Most of us aren't completely single-minded and specialised on a single skill.
My main part in this project is being one of the scholarly editors, but I have also entered parts of the music and can do a lot for pinpointing typographical issues.
The guy who is responsible for the fine-engraving has a good eye on his own and can also spot questionable issues in the musical text.

We have developed the concept of a “draft mode” that allows us to visualize (i.\,e.\ mostly colorize) issues and have some kind of “in-source” communication through messages that are written to the command line.
When a piece is finished we just switch to “publication mode” and have our print-ready scores.
Comments in the source files increase the impact of this concept, but the next project will take this a major step further.
Currently I'm developing a system that will allow comprehensive annotations inside the source files.
This way we'll have automatic lists of \textsc{todo}-items, issues and questions etc.\ that are generated while compiling the scores.
And ultimately we'll have the entries for the critical report right in the source files!

As all general layout and styling is done in central style sheets it isn't an issue at all to keep the different scores consistent. We don't even have to decide upon it before starting work.
All changes to the layout are automatically propagated to all scores, and it would for example be possible that someone is assigned the task to develop the general appearance of the publication \emph{while the others are working on the edition}, always having the latest version of the musical text as example material.
That way the edition can also automatically benefit from improvements of LilyPond that are released along the way.
Only when starting the final beautification would the development of the layout settings have to stop---but that's a restriction that is inherent in the matter and not imposed by the technical infrastructure.

While this isn't that important for small individual scores it is a major “selling point” for ambitious and large-scale projects.
And I would love to discuss and experience the impact this could have on working on a scholarly edition with numerous volumes and multiple editors.
Remember what I wrote about plain text files outliving operating systems' lifecycles?
Such a system could very well be the perfect match for a long-running critical edition.

\section{Book preparation}
The same is true for the preparation of books, and of compilation books from more than one author in particular.
All collaborators can seamlessly work together in a shared code base: the author(s), editors, typesetters, and maybe additional specialists preparing figures or music examples.
A collaborative set-up provides an efficient workflow between an author and his editor, and it can be particularly useful when proof-reading or documents or polishing them linguistically with many assistants.
It has to be said that such a work-flow is already standard in many scientific journals in other disciplines.

Of course the musical edition described in the previous section is also a “book” in this sense, as the scores are created with LilyPond and included in a \LaTeX{} document.
The complete volume can be compiled at any time and reflects the current state of the development of the scores.


\section{“Crowd Editing”}
\label{sec:pt_crowd-editing}

It isn't really common yet because it can exclusively be inspired by the use of workflows that are driven by version control.
But with the capability to manage contributions by a (practically) unlimited number of participants it is possible to extend the concepts from the the two previous sections and create musical scores with a large community.
This way the workload can be “clustered” among a potentially great number of people, each one according to his capabilities and special knowledge (about specific instruments for example), and large quantities of music entered in astonishingly little time.
While this doesn't save actual working hours it can be used to process them in parallel.
Even in a large-scale symphonic score each single part is quite manageable, and if there is one contributor for each part (or better: two contributors for two parts who do a peer-review before submitting) the score should grow rapidly.
I know of at least one semi-professional choir that has by now switched to preparing its scores in such a social manner.

In such a context the aspect of programmability may once more become important.
While the individual contributors don't have to be programmers at all the “project” can be extensively programmed.
It can gain advanced and specialized functionality, benefit from automatic project management or just from giving the “ordinary engraver” an easy-to-use interface.

\section{Single-source Publishing}
\label{sec:pt_single-source-publishing}

Plain text files are a good starting point for creating documents for different output formats.
One example already discussed is the possibility to create several different scores (or parts) with LilyPond from a single set of input files.
I don't have concrete experiences to present but it's inherent in the nature of plain text files that they are good for use in single-source publishing.
This can easily apply to generating documents for printing, beamer presentation, mobile devices and web pages from single sources, to name just a few.
I think---and hope---that this can also be made very fruitful in the light of current discussions to present scholarly editions in modern ways beyound printed scores.

\end{document}